(Main) = API.check_all

// Prelude
// -------

// U60.if -(r: Type) U60 r r : r
(U60.if 0 then else) = else
(U60.if 1 then else) = then

// U60.equal U60 U60 : Bool
(U60.equal a b) = (U60.if (== a b) True False)

// U60.max U60 U60 : Bool
(U60.max a b) = (U60.if (> a b) a b)

// Name.length Name : U60
(Name.length name) = (String.length (Show.name name))

// If -(r: Type) Bool r r : r
(Bool.if False then else) = else
(Bool.if True  then else) = then

// Bool.and Bool Bool : Bool
(Bool.and True  b) = b
(Bool.and False b) = False

// Bool.or Bool Bool : Bool
(Bool.or True  b) = True
(Bool.or False b) = b

// Maybe.case -(a: Type) -(r: Type) (Maybe a) r (a -> r) : r
(Maybe.case None       none some) = none
(Maybe.case (Some val) none some) = (some val)

// Maybe.bind -(a: Type) -(b: Type) (Maybe a) : (a -> (Maybe b)) (Maybe b)
(Maybe.bind None)     = @cont None
(Maybe.bind (Some x)) = @cont (cont x)

// Maybe.try
(Maybe.try List.nil                  df) = df
(Maybe.try (List.cons (Some x) rest) df) = x
(Maybe.try (List.cons None     rest) df) = (Maybe.try rest df)

// List.at -(a: Type) (List a) U60 : (Maybe a)
(List.at (List.cons x xs) 0) = (Some x)
(List.at (List.cons x xs) n) = (List.at xs (- n 1))
(List.at List.nil         n) = None

// List.tail -(a: Type) (List a) : (List a)
(List.tail (List.cons x xs)) = xs
(List.tail List.nil)         = List.nil

// List.reverse -(a: Type) (List a) : (List a)
(List.reverse xs) = (List.reverse.go xs [])

// List.reverse.go -(a: Type) (List a) (List a) : (List a)
(List.reverse.go List.nil         res) = res
(List.reverse.go (List.cons x xs) res) = (List.reverse.go xs (List.cons x res))

// List.join (str: (List String)) (sep: String) : String
(List.join list sep) = (List.join.go list sep True)

// List.join.go (str: (List String)) (sep: String) (fst: Bool) : String
(List.join.go (List.cons head tail) sep fst) = (Text [(Bool.if fst "" sep) head (List.join.go tail sep False)])
(List.join.go List.nil              sep fst) = String.nil

// List.map -(a: Type) -(b: Type)  (fn: a -> b) (List a): (List.b)
(List.map fn (List.cons head tail)) = (List.cons (fn head) (List.map fn tail))
(List.map fn List.nil) = List.nil

// String.cut String : String
(String.cut str) = (String.cut.go str "(...)" 2048)

// String.cut.go String String String : String
(String.cut.go String.nil         df n) = String.nil
(String.cut.go (String.cons x xs) df 0) = df
(String.cut.go (String.cons x xs) df n) = (String.cons x (String.cut.go xs df (- n 1)))

// String.concat String String : String
(String.concat String.nil         ys) = ys
(String.concat (String.cons x xs) ys) = (String.cons x (String.concat xs ys))

// String.is_empty String : Bool
(String.is_empty String.nil) = True
(String.is_empty other)      = False

// String.length String : U60
(String.length String.nil)         = 0
(String.length (String.cons x xs)) = (+ 1 (String.length xs))

// String.pad_right (str: String) (chr: U60) (len: U60) : String
(String.pad_right str                chr 0)   = String.nil
(String.pad_right (String.cons x xs) chr len) = (String.cons x   (String.pad_right xs         chr (- len 1)))
(String.pad_right String.nil         chr len) = (String.cons chr (String.pad_right String.nil chr (- len 1)))

// Text (List String) : String
(Text List.nil)         = String.nil
(Text (List.cons x xs)) = (String.concat x (Text xs))

// Color String : String
(Color x) = (Text [ (String.cons 27 String.nil) "[" x "m" ])

// Line : String
Line = (String.cons 10 String.nil)

// Subst
// -----

// type Subst {
//    (End)                            // end of subst list
//    (Unf (rest: Subst))              // unfilled hole
//    (Sub (term: Term) (rest: Subst)) // subst hole
// }

// Subst.look Subst U60 : (Maybe Term)
(Subst.look End             0) = None
(Subst.look (Unf rest)      0) = None
(Subst.look (Sub term rest) 0) = (Some term)
(Subst.look End             n) = None
(Subst.look (Unf rest)      n) = (Subst.look rest (- n 1))
(Subst.look (Sub term rest) n) = (Subst.look rest (- n 1))

// Subst.fill Subst U60 Term : Subst
(Subst.fill End             0 term) = (Sub term End)
(Subst.fill (Unf rest)      0 term) = (Sub term rest)
(Subst.fill (Sub lost rest) 0 term) = (Sub term rest)
(Subst.fill End             n term) = (Unf (Subst.fill End  (- n 1) term))
(Subst.fill (Unf rest)      n term) = (Unf (Subst.fill rest (- n 1) term))
(Subst.fill (Sub keep rest) n term) = (Sub keep (Subst.fill rest (- n 1) term))

// Context
// -------

// type Context {
//   Empty : Context
//   (Entry (name: U60) (type: Term) (vals: (List Term))) : Context
// }

// Context.extend U60 Term (List Term) : Context
(Context.extend (Entry name type vals rest) n t v) = (Entry name type vals (Context.extend rest n t v))
(Context.extend Empty                       n t v) = (Entry n t v Empty)

// Context.add_value Context U60 Term : Context
(Context.add_value (Entry name type vals rest) 0 val) = (Entry name type (List.cons val vals) rest)
(Context.add_value (Entry name type vals rest) n val) = (Entry name type vals (Context.add_value rest (- n 1) val))
(Context.add_value Empty                       n val) = Empty

// Context.find -(r: Type) Context U60 r (U60 -> Term -> (List Term) -> r) : r
(Context.find (Entry name type vals rest) 0 d f) = (f name type vals)
(Context.find (Entry name type vals rest) i d f) = (Context.find rest (- i 1) d f)
(Context.find Empty                       i d f) = d

// Context.shrink Context : Context
(Context.shrink Empty)                        = Empty // FIXME: can't move to last line; investigate
(Context.shrink (Entry name type vals Empty)) = Empty
(Context.shrink (Entry name type vals rest))  = (Entry name type vals (Context.shrink rest))

// Context.is_empty Context : Context
(Context.is_empty (Entry name type vals rest)) = False
(Context.is_empty Empty)                       = True

// Context.max_name_length Context : U60
(Context.max_name_length Empty) = 0
(Context.max_name_length (Entry name type vals rest)) =
  (U60.max (Name.length name) (Context.max_name_length rest))

// Checker Monad
// -------------

// type Result (a : Type) {
//   (Checked (ctx: Context) (dep: U60) (rhs: Bool) (sub: Subst) (ret: a))
//   (Errored (ctx: Context) (sub: Subst) (err: Error))
// }

// Checker (a : Type) : Type {
//   (context         : Context)
//   (depth           : U60)
//   (right_hand_side : Bool)
//   (substitutions   : Subst)
//   (Result a)
// }

// Checker.bind -(a: Type) -(b: Type) (Checker a) : (a -> Checker b) (Checker b)
(Checker.bind checker) = λnext λctx λdep λrhs λsub ((Checker.bind.result (checker ctx dep rhs sub)) next)

// Checker.bind.result -(a: Type) -(b: Type) (Result a) : (a -> Checker b) (Result b)
(Checker.bind.result (Checked ctx dep rhs sub val)) = λnext (next val ctx dep rhs sub)
(Checker.bind.result (Errored ctx sub err))         = λnext (Errored ctx sub err)

// Checker.done -(a: Type) (x: a) : (Checker a)
(Checker.done val) = λctx λdep λrhs λsub (Checked ctx dep rhs sub val)

// Checker.fail -(a: Type) (err: Error) : (Checker a)
(Checker.fail err) = λctx λdep λrhs λsub (Errored ctx sub err)

// Checker.run -(a: Type) (Checker a) (rhs: Bool) : (Result a)
(Checker.run chk rhs) = (chk Empty 0 rhs End)

// Checker.get_context : (Checker Context)
(Checker.get_context) = λctx λdep λrhs λsub
  (Checked ctx dep rhs sub ctx)

// Checker.get_depth : (Checker U60)
(Checker.get_depth) = λctx λdep λrhs λsub
  (Checked ctx dep rhs sub dep)

// Checker.get_subst : (Checker Subst)
(Checker.get_subst) = λctx λdep λrhs λsub
  (Checked ctx dep rhs sub sub)

// Checker.get_right_hand_side : (Checker U60)
(Checker.get_right_hand_side) = λctx λdep λrhs λsub
  (Checked ctx dep rhs sub rhs)

// Checker.set_right_hand_side Bool : (Checker Unit)
(Checker.set_right_hand_side rhs) = λctx λdep λold_rhs λsub
  (Checked ctx dep rhs sub Unit)

// Checker.extend U60 Term (List Term) : (Checker Unit)
(Checker.extend name type vals) = λctx λdep λrhs λsub
  (Checked (Context.extend ctx name type vals) (+ dep 1) rhs sub Unit)

// Checker.shrink : (Checker Unit)
(Checker.shrink) = λctx λdep λrhs λsub
  (Checked (Context.shrink ctx) (- dep 1) rhs sub Unit)

// Checker.extended -(a: Type) (Checker a) U60 Term Term : (Checker a)
(Checker.extended checker name type vals) = 
  ask (Checker.bind (Checker.extend name type vals))
  ask got = (Checker.bind checker)
  ask (Checker.bind Checker.shrink)
  (Checker.done got)

// Checker.find -(r: Type) U60 r (U60 -> Term -> (List Term) -> r) : (Checker r)
(Checker.find idx d f) = λctx λdep λrhs λsub
  (Checked ctx dep rhs sub (Context.find ctx idx d f))

// Checker.add_value (idx: U60) (val: Term) : (Checker Unit)
(Checker.add_value idx val) = λctx λdep λrhs λsub
  (Checked (Context.add_value ctx idx val) dep rhs sub Unit)

// Checker.find -(r: Type) U60 r (U60 -> Term -> (List Term) -> r) : (Checker r)
(Checker.find idx d f) = λctx λdep λrhs λsub
  (Checked ctx dep rhs sub (Context.find ctx idx d f))

// Checker.fill (idx: U60) (val: Term) : (Checker Unit)
(Checker.fill idx val) = λctx λdep λrhs λsub
  (Checked ctx dep rhs (Subst.fill sub idx val) Unit)

// Checker.look (idx: U60) : (Checker (Maybe Term))
(Checker.look idx) = λctx λdep λrhs λsub
  (Checked ctx dep rhs sub (Subst.look sub idx))

// Term utils
// ----------

// Term.if_all -(r: Type) Term (U60 U60 -> Term -> (Term -> Term) -> r) r : r
(Term.if_all (All orig name type body) then else) = (then orig name type body)
(Term.if_all other                     then else) = else

// Term.orig
(Term.get_origin (Typ orig))                      = orig
(Term.get_origin (Var orig name index))           = orig
(Term.get_origin (Hol orig numb))                 = orig
(Term.get_origin (All orig name type body))       = orig
(Term.get_origin (Lam orig name body))            = orig
(Term.get_origin (App orig func argm))            = orig
(Term.get_origin (Let orig name expr body))       = orig
(Term.get_origin (Ann orig expr type))            = orig
(Term.get_origin (CtX name orig args))             = orig
(Term.get_origin (FnX name orig args))             = orig
(Term.get_origin (Hlp orig))                      = orig
(Term.get_origin (U60 orig))                      = orig
(Term.get_origin (Num orig numb))                 = orig
(Term.get_origin (Op2 orig oper val0 val1))       = orig

// Term.set_origin
(Term.set_origin new_orig (Typ orig))                      = (Typ new_orig)
(Term.set_origin new_orig (Var orig name index))           = (Var new_orig name index)
(Term.set_origin new_orig (Hol orig numb))                 = (Hol new_orig numb)
(Term.set_origin new_orig (All orig name type body))       = (All new_orig name type body)
(Term.set_origin new_orig (Lam orig name body))            = (Lam new_orig name body)
(Term.set_origin new_orig (App orig func argm))            = (App new_orig func argm)
(Term.set_origin new_orig (Let orig name expr body))       = (Let new_orig name expr body)
(Term.set_origin new_orig (Ann orig expr type))            = (Ann new_orig expr type)
(Term.set_origin new_orig (CtX name orig args))             = (CtX name new_orig args)
(Term.set_origin new_orig (FnX name orig args))             = (FnX name new_orig args)
(Term.set_origin new_orig (Hlp orig))                      = (Hlp new_orig)
(Term.set_origin new_orig (U60 orig))                      = (U60 new_orig)
(Term.set_origin new_orig (Num orig numb))                 = (Num new_orig numb)
(Term.set_origin new_orig (Op2 orig oper val0 val1))       = (Op2 new_orig oper val0 val1)

// SO = Term.set_origin
(SO new_orig term) = (Term.set_origin new_orig term)

// Term.fillable Term Subst : Bool
// -------------------------------

(Term.fillable term End) =
  False

(Term.fillable (Typ orig) sub) =
  False

(Term.fillable (Var orig name index) sub) =
  False

(Term.fillable (All orig name type body) sub) =
  let type = (Term.fillable type           sub)
  let body = (Term.fillable (body (Hlp 0)) sub)
  (Bool.or type body)

(Term.fillable (Lam orig name body) sub) =
  let body = (Term.fillable (body (Hlp 0)) sub)
  body

(Term.fillable (App orig func argm) sub) =
  let func = (Term.fillable func sub)
  let argm = (Term.fillable argm sub)
  (Bool.or func argm)

(Term.fillable (Let orig name expr body) sub) =
  let expr = (Term.fillable expr sub)
  let body = (Term.fillable (body (Hlp 0)) sub)
  (Bool.or expr body)

(Term.fillable (Ann orig expr type) sub) =
  let expr = (Term.fillable expr sub)
  let type = (Term.fillable type sub)
  (Bool.or expr type)

(Term.fillable (CtX name orig List.nil) sub) =
  False

(Term.fillable (CtX name orig (List.cons head tail)) sub) =
  (Bool.or (Term.fillable head sub) (Term.fillable (CtX name orig tail) sub))

(Term.fillable (FnX name orig List.nil) sub) =
  False

(Term.fillable (FnX name orig (List.cons head tail)) sub) =
  (Bool.or (Term.fillable head sub) (Term.fillable (FnX name orig tail) sub))

(Term.fillable (Hlp orig) sub) =
  False

(Term.fillable (U60 orig) sub) =
  False

(Term.fillable (Num orig numb) sub) =
  False

(Term.fillable (Op2 orig oper val0 val1) sub) =
  let val0 = (Term.fillable val0 sub)
  let val1 = (Term.fillable val1 sub)
  (Bool.or val0 val1)

(Term.fillable (Hol orig numb) sub) =
  (Maybe.case (Subst.look sub numb) False λval(True))

// Term.fill Term Subst : (Pair Term Bool)
// ---------------------------------------

(Term.fill term End)                            = term
(Term.fill (Typ orig) sub)                      = (Typ orig)
(Term.fill (Var orig name index) sub)           = (Var orig name index)
(Term.fill (All orig name type body) sub)       = (All orig name (Term.fill type sub) λx (Term.fill (body x) sub))
(Term.fill (Lam orig name body) sub)            = (Lam orig name λx (Term.fill (body x) sub))
(Term.fill (App orig func argm) sub)            = (APP orig (Term.fill func sub) (Term.fill argm sub))
(Term.fill (Let orig name expr body) sub)       = (LET orig name (Term.fill expr sub) λx (Term.fill (body x) sub))
(Term.fill (Ann orig expr type) sub)            = (ANN orig (Term.fill expr sub) (Term.fill type sub))
(Term.fill (CtX name orig args) sub)             = (CtX name orig (List.map @x(Term.fill x sub) args))
(Term.fill (FnX name orig args) sub)             = (FNX name orig (List.map @x(Term.fill x sub) args))
(Term.fill (Hlp orig) sub)                      = (Hlp orig)
(Term.fill (U60 orig) sub)                      = (U60 orig)
(Term.fill (Num orig numb) sub)                 = (Num orig numb)
(Term.fill (Op2 orig oper val0 val1) sub)       = (OP2 orig oper (Term.fill val0 sub) (Term.fill val1 sub))
(Term.fill (Hol orig numb) sub)                 = (Maybe.case (Subst.look sub numb) (Hol orig numb) λval (Term.fill val sub))

// Eval Term (List Term) : Term
// ----------------------------

(Eval (Typ orig))                              = (Typ orig)
(Eval (Var orig name index))                   = (Var orig name index)
(Eval (Hol orig numb))                         = (Hol orig numb)
(Eval (All orig name type body))               = (All orig name (Eval type) λx (Eval (body x)))
(Eval (Lam orig name body))                    = (Lam orig name λx (Eval (body x)))
(Eval (Let orig name expr body))               = (LET orig name (Eval expr) λx (Eval (body x)))
(Eval (Ann orig expr typ))                     = (ANN orig (Eval expr) (Eval typ))
(Eval (App orig func argm))                    = (APP orig (Eval func) (Eval argm))
(Eval (CtX ctid orig args))                     = (CtX ctid orig (List.map @x(Eval x) args))
(Eval (FnX ctid orig args))                     = (FNX ctid orig (List.map @x(Eval x) args))
(Eval (Hlp orig))                              = (Hlp orig)
(Eval (U60 orig))                              = (U60 orig)
(Eval (Num orig numb))                         = (Num orig numb)
(Eval (Op2 orig oper val0 val1))               = (OP2 orig oper (Eval val0) (Eval val1))

// Equal Term Term : (Checker Bool)
// --------------------------------

// Typ equality
(Equal (Typ orig) (Typ orig)) =
  (Checker.done True)

// All equality
(Equal (All a.orig a.name a.type a.body) (All b.orig b.name b.type b.body)) =
  ask dep  = (Checker.bind Checker.get_depth)
  ask type = (Checker.bind (Equal a.type b.type))
  ask body = (Checker.bind (Checker.extended (Equal (a.body (Var a.orig a.name dep)) (b.body (Var b.orig b.name dep))) Null Null Null))
  (Checker.done (Bool.and type body))

// Lam equality
(Equal (Lam a.orig a.name a.body) (Lam b.orig b.name b.body)) =
  ask dep  = (Checker.bind Checker.get_depth)
  ask body = (Checker.bind (Checker.extended (Equal (a.body (Var a.orig a.name dep)) (b.body (Var b.orig b.name dep))) Null Null Null))
  (Checker.done body)

// App equality
(Equal (App a.orig a.func a.argm) (App b.orig b.func b.argm)) =
  ask func = (Checker.bind (Equal a.func b.func))
  ask argm = (Checker.bind (Equal a.argm b.argm))
  (Checker.done (Bool.and func argm))

// Let equality
(Equal (Let a.orig a.name a.expr a.body) (Let b.orig b.name b.expr b.body)) =
  ask dep  = (Checker.bind Checker.get_depth)
  ask expr = (Checker.bind (Equal a.expr b.expr))
  ask body = (Checker.bind (Checker.extended (Equal (a.body (Var a.orig a.name dep)) (b.body (Var b.orig b.name dep))) Null Null Null))
  (Checker.done (Bool.and expr body))

// Ann equality
(Equal (Ann a.orig a.expr a.type) (Ann b.orig b.expr b.type)) =
  ask expr = (Checker.bind (Equal a.expr b.expr))
  ask type = (Checker.bind (Equal a.type b.type))
  (Checker.done (Bool.and expr type))

// Empty CtX equality
(Equal (CtX a.ctid a.orig List.nil) (CtX b.ctid b.orig List.nil)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  (Checker.done ctid)

// Constructors with a different number of parameters are never equal
(Equal (CtX a.ctid a.orig (List.cons a.head a.tail)) (CtX b.ctid b.orig List.nil)) =
  (Checker.done Bool.false)
  
(Equal (CtX a.ctid a.orig List.nil) (CtX b.ctid b.orig (List.cons b.head b.tail))) =
  (Checker.done Bool.false)

// Nonempty CtX equality.  
(Equal (CtX a.ctid a.orig (List.cons a.head a.tail)) (CtX b.ctid b.orig (List.cons b.head b.tail))) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  ask head = (Checker.bind (Equal a.head b.head))
  // compare both tails, to check whether they are equal
  ask tail = (Checker.bind (Equal (CtX a.ctid a.orig a.tail) (CtX b.ctid b.orig b.tail)))
  (Checker.done (Bool.and ctid (Bool.and head tail)))


// Empty FnX equality
(Equal (FnX a.ctid a.orig List.nil) (FnX b.ctid b.orig List.nil)) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  (Checker.done ctid)

// Constructors with a different number of parameters are never equal
(Equal (FnX a.ctid a.orig (List.cons a.head a.tail)) (FnX b.ctid b.orig List.nil)) =
  (Checker.done Bool.false)
  
(Equal (FnX a.ctid a.orig List.nil) (FnX b.ctid b.orig (List.cons b.head b.tail))) =
  (Checker.done Bool.false)

// Nonempty FnX equality.  
(Equal (FnX a.ctid a.orig (List.cons a.head a.tail)) (FnX b.ctid b.orig (List.cons b.head b.tail))) =
  let ctid = (U60.equal (HashOf a.ctid) (HashOf b.ctid))
  ask head = (Checker.bind (Equal a.head b.head))
  ask tail = (Checker.bind (Equal (FnX a.ctid a.orig a.tail) (FnX b.ctid b.orig b.tail)))
  (Checker.done (Bool.and ctid (Bool.and head tail)))

// Hlp equality
(Equal (Hlp a.orig) (Hlp b.orig)) =
  (Checker.done True)

// U60 equality
(Equal (U60 a.orig) (U60 b.orig)) =
  (Checker.done True)

// Num equality
(Equal (Num a.orig a.numb) (Num b.orig b.numb)) =
  (Checker.done (U60.equal a.numb b.numb))

// Op2 equality
(Equal (Op2 a.orig a.oper a.val0 a.val1) (Op2 b.orig b.oper b.val0 b.val1)) =
  ask val0 = (Checker.bind (Equal a.val0 b.val0))
  ask val1 = (Checker.bind (Equal a.val1 b.val1))
  (Checker.done (Bool.and val0 val1))

// Hol equality #0
(Equal (Hol a.orig a.numb) b) =
  (Equal.hol a.orig a.numb b)

// Hol equality #1
(Equal a (Hol b.orig b.numb)) =
  (Equal.hol b.orig b.numb a)

// Var equality #0
(Equal (Var a.orig a.name a.index) b) =
  ask rhs = (Checker.bind (Checker.get_right_hand_side))
  (Equal.var rhs a.orig a.name a.index b)

// Var equality #1
(Equal a (Var b.orig b.name b.index)) =
  ask rhs = (Checker.bind (Checker.get_right_hand_side))
  (Equal.var rhs b.orig b.name b.index a)

// Not equal
(Equal a b) =
  ask sub = (Checker.bind Checker.get_subst)
  (Bool.if (Bool.or (Term.fillable a sub) (Term.fillable b sub))
    (Equal (Term.fill a sub) (Term.fill b sub))
    (Checker.done False))

// Equal.var (rhs: Bool) (origin: U60) (index: U60) (b: Term) : (Checker bool)
// ---------------------------------------------------------------------------
// A variable is equal to a term when any of its reductions is

// If on LHS, extend the variable's equality list
// If on RHS, check if a and b are equal

// Variable checker
(Equal.var False a.orig a.name a.index b) =
  ask (Checker.bind (Checker.add_value a.index b))
  (Checker.done True)
(Equal.var True a.orig a.name a.index (Var b.orig b.name b.index)) =
  (Bool.if (U60.equal a.index b.index)
    (Checker.done True)
    ask a.val = (Checker.bind (Checker.find a.index [] λnλtλv(v)))
    ask b.val = (Checker.bind (Checker.find b.index [] λnλtλv(v)))
    ask a.chk = (Checker.bind (Equal.var.try_values a.val (Var b.orig b.name b.index)))
    ask b.chk = (Checker.bind (Equal.var.try_values b.val (Var a.orig a.name a.index)))
    (Checker.done (Bool.or a.chk b.chk)))
(Equal.var True a.orig a.name a.index b) =
  ask sub = (Checker.bind Checker.get_subst)
  (Bool.if (Term.fillable b sub)
    (Equal (Var a.orig a.name a.index) (Term.fill b sub))
    ask a.val = (Checker.bind (Checker.find a.index [] λnλtλv(v)))
    (Equal.var.try_values a.val b))

// Checks if any of a set of reductions is equal
(Equal.var.try_values (List.cons a as) b) =
  ask head = (Checker.bind (Equal a b))
  (Bool.if head
    (Checker.done True)
    (Equal.var.try_values as b))
(Equal.var.try_values List.nil b) =
  (Checker.done False)

// Equal.hol (origin: U60) (numb: U60) (b: Term) : (Checker bool)
// --------------------------------------------------------------

// Hole checker
(Equal.hol a.orig a.numb b) =
  ask got = (Checker.bind (Checker.look a.numb))
  (Equal.hol.val got a.orig a.numb b)

// Hole has no value yet, so we set it
(Equal.hol.val None a.orig a.numb b) =
  ask (Checker.bind (Checker.fill a.numb b))
  (Checker.done True)

// Hole has a value, so we compare it
(Equal.hol.val (Some a.val) a.orig a.numb b) =
  (Equal a.val b)

// Infer Term : (Checker Term)
// ---------------------------

// Infers Var
(Infer (Var orig name index)) =
  ask got_type = (Checker.bind (Checker.find index None λnλtλv(Some t)))
  (Maybe.case got_type
    (Checker.fail (UnboundVariable (Var orig name index)))
    λvar_type (Checker.done var_type))

// Infers Hol
(Infer (Hol orig numb)) =
  (Checker.fail (CantInferHole (Hol orig numb)))

// Infers Typ
(Infer (Typ orig)) =
  (Checker.done (Typ orig))

// Infers All
(Infer (All orig name type body)) =
  ask dep      = (Checker.bind Checker.get_depth)
  ask type_chk = (Checker.bind (Check type (Typ orig)))
  ask body_chk = (Checker.bind (Checker.extended (Check (body (Var orig name dep)) (Typ orig)) name type []))
  (Checker.done (Typ orig))

// Infers Lam
(Infer (Lam orig name body)) =
  (Checker.fail (CantInferLambda (Lam orig name body)))

// Infers App
(Infer (App orig func argm)) =
  ask sub      = (Checker.bind Checker.get_subst)
  ask func_typ = (Checker.bind (Infer func))
  (Term.if_all func_typ
    // then
    λfunc_typ_orig λfunc_typ_name λfunc_typ_type λfunc_typ_body
      ask argm_ok = (Checker.bind (Check argm func_typ_type))
      (Checker.done (func_typ_body (Eval argm)))
    // else
    (Checker.fail (InvalidCall (App orig func argm))))

// Infers Let
(Infer (Let orig name expr body)) =
  ask dep      = (Checker.bind Checker.get_depth)
  ask expr_typ = (Checker.bind (Infer expr))
  ask body_typ = (Checker.bind (Checker.extended (Infer (body (Var orig name dep))) name expr_typ [(Eval expr)]))
  (Checker.done body_typ)

// Infers Ann
(Infer (Ann orig expr type)) =
  ask expr_chk = (Checker.bind (Check expr (Eval type)))
  (Checker.done type)

(Infer.ct_helper (CtX ctid orig List.nil)) =
  (Checker.done (CtX ctid orig List.nil))

(Infer.ct_helper (CtX ctid orig (List.cons head tail))) =
  ask inner = (Checker.bind (Infer.ct_helper (CtX ctid orig tail)))
  (Checker.done (App orig inner head))

(Infer (CtX ctid orig (List.cons head tail))) =
  ask inner = (Checker.bind (Infer.ct_helper (CtX ctid orig (List.reverse (List.cons head tail)))))
  ask inner2 = (Checker.bind (Infer inner))
  (Checker.done inner2)

(Infer (CtX ctid orig List.nil)) =
  (Checker.done (TypeOf ctid))
// Helper function to infer FnX.
(Infer.fn_helper (FnX ctid orig List.nil)) =
  (Checker.done (FnX ctid orig List.nil))

(Infer.fn_helper (FnX ctid orig (List.cons head tail))) =
  ask inner = (Checker.bind (Infer.fn_helper (FnX ctid orig tail)))
  (Checker.done (App orig inner head))

// Infers nonempty FnX
(Infer (FnX ctid orig (List.cons head tail))) =
  ask inner = (Checker.bind (Infer.fn_helper (FnX ctid orig (List.reverse (List.cons head tail)))))
  ask inner = (Checker.bind (Infer inner))
  (Checker.done inner)

// Infers empty FnX
(Infer (FnX ctid orig List.nil)) =
  (Checker.done (TypeOf ctid))
  
// Infers Hlp
(Infer (Hlp orig)) =
  (Checker.done (Hlp 0))

// Infers U60
(Infer (U60 orig)) =
  (Checker.done (Typ 0))

// Infers Num
(Infer (Num orig numb)) =
  (Checker.done (U60 0))

// Infers Op2
(Infer (Op2 orig oper val0 val1)) =
  ask val0_chk = (Checker.bind (Check val0 (U60 0)))
  ask val1_chk = (Checker.bind (Check val1 (U60 0)))
  (Checker.done (U60 0))

// Check Term Term : (Checker Unit)
// --------------------------------

// Checks Lam 
(Check (Lam orig name body) type) =
  ask sub = (Checker.bind Checker.get_subst)
  ((Term.if_all type
    λt_orig λt_name λt_type λt_body λorig λname λbody
      ask dep      = (Checker.bind Checker.get_depth)
      ask body_chk = (Checker.bind (Checker.extended (Check (body (Var orig name dep)) (t_body (Var t_orig t_name dep))) name t_type []))
      (Checker.done Unit)
    λorig λname λbody
      (Checker.fail (CantInferLambda (Lam orig name body))))
    orig name body)

// Checks Let
(Check (Let orig name expr body) type) =
  ask dep      = (Checker.bind Checker.get_depth)
  ask expr_typ = (Checker.bind (Infer expr))
  ask body_chk = (Checker.bind (Checker.extended (Check (body (Var orig name dep)) type) name expr_typ [(Eval expr)]))
  (Checker.done Unit)

// Checks Var
(Check (Var orig name index) type) =
  ask rhs = (Checker.bind Checker.get_right_hand_side)
  (Bool.if rhs
    (Check.compare (Var orig name index) type)
    (Checker.extend name type List.nil))

// Checks Hol
(Check (Hol orig numb) type) =
  (Checker.done Unit)

// Checks others
(Check term type) =
  (Check.compare term type)

// Compares two terms for equality
(Check.compare term type) =
  ask term_typ = (Checker.bind (Infer term))
  ask is_equal = (Checker.bind (Equal term_typ type))
  (Bool.if is_equal
    (Checker.done Unit)
    (Checker.fail (TypeMismatch term type term_typ)))

// Check.verify Verifier (List Term) : (Checker Unit)
// --------------------------------------------------

(Check.verify (LHS arg args) (All orig name type body)) =
  ask arg_chk  = (Checker.bind (Check arg type))
  ask args_chk = (Checker.bind (Check.verify args (body arg)))
  (Checker.done Unit)
(Check.verify (LHS arg args) other) =
  (Checker.fail (TooManyArguments arg))
(Check.verify (RHS expr) type) =
  ask (Checker.bind (Checker.set_right_hand_side True))
  ask expr_chk = (Checker.bind (Check expr type))
  (Checker.done Unit)

// APP U60 Term Term : Term
// ------------------------

(APP orig (Lam orig name fbody) argm) = (fbody argm)
(APP orig func                  argm) = (App orig func argm)

// LET U60 Name Term Term : Term
// -----------------------------

(LET orig name expr body) = (body expr)

// ANN U60 Term Term : Term
// -------------------------

(ANN orig expr type) = expr

// OP2 U60 Term Term : Term
// ------------------------

(OP2 orig ADD  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (+  a.numb b.numb))
(OP2 orig SUB  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (-  a.numb b.numb))
(OP2 orig MUL  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (*  a.numb b.numb))
(OP2 orig DIV  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (/  a.numb b.numb))
(OP2 orig MOD  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (%  a.numb b.numb))
(OP2 orig AND  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (&  a.numb b.numb))
(OP2 orig OR   (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (|  a.numb b.numb))
(OP2 orig XOR  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (^  a.numb b.numb))
(OP2 orig SHL  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (<< a.numb b.numb))
(OP2 orig SHR  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (>> a.numb b.numb))
(OP2 orig LTN  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (<  a.numb b.numb))
(OP2 orig LTE  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (<= a.numb b.numb))
(OP2 orig EQL  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (== a.numb b.numb))
(OP2 orig GTE  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (>= a.numb b.numb))
(OP2 orig GTN  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (>  a.numb b.numb))
(OP2 orig NEQ  (Num a.orig a.numb) (Num b.orig b.numb)) = (Num 0 (!= a.numb b.numb))
(OP2 orig oper val0                val1)                = (Op2 orig oper val0 val1)

// Stringification
// ---------------

// FIXME: show is quadratic; must improve

(Show term) =
  let sugars = [
    (Show.sugar.string term)
    (Show.sugar.list term)
  ]
  (Maybe.try sugars (Show.go term))

(Show.go (CtX ctid orig args)) = (Text [
  "(" (NameOf ctid) (List.join (List.map @arg(Show.go arg) args) " " ) ")"
])

(Show.go (FnX ctid orig args)) = (Text [
  "(" (NameOf ctid) (List.join (List.map @arg(Show.go arg) args) " " ) ")"
])


(Show.go (Var orig name index)) = (Text [
  (Show.name name)
])

(Show.go (Hol orig numb)) = (Text [
  "_" (Show.u60 numb)
])

(Show.go (Typ orig)) = (Text [
  "Type"
])

// TODO: omit unecessary parenthesis
(Show.go (All orig name type body)) =
  (U60.if (== name 63) // underscore
    (Text [
      "(" (Show type) " -> " (Show (body (Var orig name 0))) ")"
    ])
    (Text [
      "(" (Show.name name) ": " (Show type) ") "
      (Show (body (Var orig name 0)))
    ]))

(Show.go (Lam orig name body)) =
  (Text [
    "@" (Show.name name) " "
    (Show (body (Var orig name 0)))
  ])

(Show.go (Let orig name expr body)) = (Text [
  "let " (Show.name name) " = " (Show (expr (Var orig name 0))) "; "
  (Show (body (Var orig name 0)))
])

(Show.go (Ann orig expr type)) = (Text [
  "{" (Show expr) " :: " (Show type) "}"
])

// TODO: omit unecessary parenthesis
(Show.go (App orig func argm)) = (Text [
  "("
  (Show func) " "
  (Show argm)
  ")"
])

(Show.go (Hlp orig)) =
  (Text [
    "?"
  ])

(Show.go (U60 orig)) =
  (Text [
    "U60"
  ])

(Show.go (Num orig numb)) =
  (Text [
    "#" (Show.u60 numb)
  ])

(Show.go (Op2 orig oper val0 val1)) =
  (Text [
    "(" (Show.oper oper) " " (Show val0) " " (Show val1) ")"
  ])

(Show.sugar.string term) =
  ask text = (Maybe.bind (Show.sugar.string.go term))
  let quot = (String.cons '"' String.nil)
  (Some (Text [quot text quot]))
(Show.sugar.string.go (CtX String.cons. orig (List.cons (Num n.orig n.numb) (List.cons tail List.nil)))) = 
  ask tail = (Maybe.bind (Show.sugar.string.go tail))
  (Some (String.cons n.numb tail))
(Show.sugar.string.go (CtX String.nil. orig List.Nil)) = (Some (String.nil))
(Show.sugar.string.go rest) = None

(Show.sugar.list term) =
  ask vals = (Maybe.bind (Show.sugar.list.go term))
  let open = "["
  let vals = (List.join vals " ")
  let clos = "]"
  (Some (Text [open vals clos]))
(Show.sugar.list.go (CtX List.cons. orig (List.cons t (List.cons head (List.cons tail List.nil))))) =
  let head = (Show head)
  ask tail = (Maybe.bind (Show.sugar.list.go tail))
  (Some (List.cons head tail))
(Show.sugar.list.go (CtX List.nil. orig (List.cons t List.nil))) =
  (Some List.nil)
(Show.sugar.list.go other) =
  None

(Show.oper ADD) = "+"
(Show.oper SUB) = "-"
(Show.oper MUL) = "*"
(Show.oper DIV) = "/"
(Show.oper MOD) = "%"
(Show.oper AND) = "&"
(Show.oper OR)  = "|"
(Show.oper XOR) = "^"
(Show.oper SHL) = "<<"
(Show.oper SHR) = ">>"
(Show.oper LNT) = "<"
(Show.oper LTE) = "<="
(Show.oper EQL) = "=="
(Show.oper GTE) = ">="
(Show.oper GTN) = ">"
(Show.oper NEQ) = "!="
(Show.oper op)  = "?"

(Show.context ctx sub) =
  (Show.context.go ctx sub (Context.max_name_length ctx))

(Show.context.go Empty sub pad) = String.nil
(Show.context.go (Entry name type vals rest) sub pad) = (Text [
  (Show.context.type name type sub pad)
  (Show.context.vals name vals sub pad)
  (Show.context.go rest sub pad)
])

(Show.context.type name type sub pad) = (Text [
  "- " (String.pad_right (Show.name name) ' ' pad) " : " (String.cut (Show (Term.fill type sub))) Line
])

(Show.context.vals name List.nil sub pad) = String.nil
(Show.context.vals name (List.cons val vals) sub pad) = (Text [
  (Color "2") "- " (String.pad_right (Show.name name) ' ' pad) " = " (String.cut (Show (Term.fill val sub))) (Color "0") Line
  (Show.context.vals name vals sub pad)
])

(Show.subst End) = "|"
(Show.subst (Unf rest)) = (Text [
  "~ ?" Line
  (Show.subst rest)
])
(Show.subst (Sub expr rest)) = (Text [
  "~ " (Show expr) Line
  (Show.subst rest)
])

// Show.u60 U60 : String
(Show.u60 n) = (Show.u60.build n String.nil)
  (Show.u60.build n str) = 
    let next = (String.cons (+ 48 (% n 10)) str)
    ((U60.if (< n 10) λx(x) λx(Show.u60.build (/ n 10) x)) next)

// Show.name U60 : String
(Show.name name) = (Show.name.go name String.nil)

// Show.name.go U60 String : String
(Show.name.go name chrs) =
  (U60.if (== name 0) chrs
    let val = (% name 64)
    let chr =
      (U60.if (== val 0) '.'
      (U60.if (& (<=  1 val) (<= val 10)) (+ (- val  1) '0')
      (U60.if (& (<= 11 val) (<= val 36)) (+ (- val 11) 'A')
      (U60.if (& (<= 37 val) (<= val 62)) (+ (- val 37) 'a')
      (U60.if (== val 63) '_' '?')))))
    (Show.name.go (/ name 64) (String.cons chr chrs)))

// API
// ---

API.check_all =
  let output = (API.output (List.reverse (API.check_functions Functions)))
  (Bool.if (String.is_empty output)
    (Text [ "All terms check." Line Line ])
    output)

API.eval_main = (Text [
  (Show (FNX Main. 0 List.nil))
  Line Line
])

(API.check_functions List.nil) = List.nil
(API.check_functions (List.cons f fs)) =
  let head = (Result f (API.check_function f))
  let tail = (API.check_functions fs)
  (List.cons head tail)

(API.check_function func) =
  let vers = (Verify func)
  let type = (TypeOf func)
  let type_check = (Checker.run (Check type (Typ 0)) True)
  let rule_check = (API.check_function.verifiers vers type)
  (List.cons type_check rule_check)

(API.check_function.verifiers List.nil type) = List.nil
(API.check_function.verifiers (List.cons verifier verifiers) type) =
  let head = (Checker.run (Check.verify verifier type) False)
  let tail = (API.check_function.verifiers verifiers type)
  (List.cons head tail)

(API.output List.nil) =
  String.nil
(API.output (List.cons (Result fnid checks) rest)) =
  (Text [
    (API.output.function fnid checks)
    (API.output rest)
  ])

(API.output.function fnid List.nil) =
  String.nil
(API.output.function fnid (List.cons (Checked ctx dep rhs sub val) checks)) =
  (Text [
    //(NameOf fnid) Line
    //(Show.subst sub) Line
    (API.output.function fnid checks)
  ])
(API.output.function fnid (List.cons (Errored ctx sub err) checks)) =
  (Text [
    (API.output.error fnid err ctx sub) Line
    (API.output.function fnid checks)
  ])

(API.output.error fnid (UnboundVariable term) ctx sub) =
  (Text [
    (Color "4") "Unbound Variable." (Color "0") Line
    (API.output.error.details fnid ctx sub term)
  ])
(API.output.error fnid (CantInferLambda term) ctx sub) =
  (Text [
    (Color "4") "Can't infer lambda." (Color "0") Line
    (API.output.error.details fnid ctx sub term)
  ])
(API.output.error fnid (CantInferHole term) ctx sub) =
  (Text [
    (Color "4") "Can't infer hole." (Color "0") Line
    (API.output.error.details fnid ctx sub term)
  ])
(API.output.error fnid (TooManyArguments term) ctx sub) =
  (Text [
    (Color "4") "Too many arguments." (Color "0") Line
    (API.output.error.details fnid ctx sub term)
  ])
(API.output.error fnid (InvalidCall term) ctx sub) =
  (Text [
    (Color "4") "Invalid call." (Color "0") Line
    (API.output.error.details fnid ctx sub term)
  ])
(API.output.error fnid (TypeMismatch term expected detected) ctx sub) =
  (Text [
    (Color "4") "Type mismatch." (Color "0") Line
    "- Expected: " (String.cut (Show (Term.fill expected sub))) Line
    "- Detected: " (String.cut (Show (Term.fill detected sub))) Line
    (API.output.error.details fnid ctx sub term)
  ])

(API.output.error.details fnid ctx sub term) =
  let orig = (Term.get_origin term)
  (Text [
    (Bool.if (Context.is_empty ctx) "" (Text [
      (Color "4") "Context:" (Color "0") Line
      (Show.context ctx sub)
    ]))
    (Color "4") "On '{{#F"(Show.u60 (>> orig 48))"F#}}':" (Color "0") Line
    "{{#R"(Show.u60 (>> orig 48))":"(Show.u60 (& orig 16777215))":"(Show.u60 (& (>> orig 24) 16777215))"R#}}" Line
  ])

// User-Defined Functions
// ----------------------
////INJECT////

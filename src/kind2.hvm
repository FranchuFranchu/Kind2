// FIXME: File is used non-linearly many time, fixing might optimize many functions
// FIXME: syntax error on `TF : (Not (T == F))`
// FIXME: variables with same names are considered equal; add an unique id?

// Kind2 was updated to save constructor names as strings, instead of
// name tables. This greatly decreased code complexity, which is important now,
// at the cost of a ~3x performance drop. This will be improved later on.
// Rewrites for {(Nat.Destroy (Nat.Pow2 N)) == Zero}:
// Before the change:
// -  8428797 for N = 14
// - 16338023 for N = 15
// - 32177923 for N = 16
// After the change:
// - 25015316 for N = 14
// - 49433198 for N = 15
// - 98263309 for N = 16

// #############################################################################
// # Prelude                                                                   #
// #############################################################################



// U60
// ===

// (U60.If U60 a a) : a
(U60.If 0 t f) = f
(U60.If 1 t f) = t

// (U60.And U60 U60) : U60
(U60.And 0 b) = 0
(U60.And 1 b) = b

// (U60.Not U60) : U60
(U60.Not 0) = 1
(U60.Not 1) = 0

// (U60.Show U60) : String
(U60.Show n) = (U60.ShowBuild n String.nil)
  (U60.ShowBuild n str) = 
    let next = (String.cons (+ 48 (% n 10)) str)
    ((U60.If (< n 10) λx(x) λx(U60.ShowBuild (/ n 10) x)) next)

// (U60.Read String) : U60
(U60.Read str) = (U60.Read.Go str 0)
  (U60.Read.Go String.nil         r) = r
  (U60.Read.Go (String.cons x xs) r) = (U60.If (& (<= '0' x) (<= x '9')) (U60.Read.Go xs (+ (* r 10) (- x '0'))) 0)



// Bool
// ====

// (If Bool a a) : a
(If False t f) = f
(If True  t f) = t



// Pair
// ====

// (Pair.Get (Pair a b) (∀a ∀b c)) : c
(Pair.Get (Pair x y) fn) = (fn x y)
(Pair.Fst (Pair x y)) = x
(Pair.Snd (Pair x y)) = y
(Pair.MutFst (Pair x y) fn) = (Pair (fn x) y)
(Pair.MutSnd (Pair x y) fn) = (Pair x (fn y))



// Trip
// ====

// (Trip.Get (Trip a b c) (∀a ∀b λc d)) : d
(Trip.Get (Trip x y z) fn) = (fn x y z)



// Maybe
// =====

// (Maybe.Case (Maybe a) p (∀a p)) : p
(Maybe.Case (Some x) case_none case_some) = (case_some x)
(Maybe.Case None     case_none case_some) = case_none

// (Maybe.Bind a_maybe:(Maybe a) b_maybe:(∀a (Maybe b))) : (Maybe b)
(Maybe.Bind (Some x) cont) = (cont x)
(Maybe.Bind None     cont) = None


// List
// ====

// (List.Map (List a) (∀a b)) : (List b)
(List.Map Nil         f) = Nil
(List.Map (Cons x xs) f) = (Cons (f x) (List.Map xs f))

// (List.Reverse (List a)) : (List a)
(List.Reverse list) = (List.Reverse.Go list [])
  (List.Reverse.Go Nil         result) = result
  (List.Reverse.Go (Cons x xs) result) = (List.Reverse.Go xs (Cons x result))

// (List.Length (List a)) : U60
(List.Length Nil)         = 0
(List.Length (Cons x xs)) = (+ 1 (List.Length xs))

// (List.IsEmpty (List a)) : Bool
(List.IsEmpty Nil)         = 1
(List.IsEmpty (Cons x xs)) = 0

// Concatenates two lists
// (List.Concat a:(List a) b:(List a)) : (List a)
(List.Concat Nil         ys) = ys
(List.Concat (Cons x xs) ys) = (Cons x (List.Concat xs ys))

// (List.Fold (List a) b (∀a ∀b (b))) : b
(List.Fold Nil         nil cons) = nil
(List.Fold (Cons x xs) nil cons) = (cons x (List.Fold xs nil cons))



// Name
// ====

(Name.Make str) = (Name str (String.Hash str))

(Name.GetHash (Name str hash)) = hash

(Name.GetString (Name str hash)) = str
(Name.GetString str) = (String.Concat "<FIXME>" str)

(Name.Equal (Name a_str a_hash) (Name b_str b_hash)) = (== a_hash b_hash)



// String
// ======

// The new line string: "\n"
// NewLine : String
NewLine = (String.cons 10 String.nil)

// Returns true if a string is empty
// (String.IsEmpty String) : Bool
(String.IsEmpty String.nil)         = True
(String.IsEmpty (String.cons x xs)) = False

// Concatenates two strings
// (String.Concat a:String b:String) : String
(String.Concat String.nil         ys) = ys
(String.Concat (String.cons x xs) ys) = (String.cons x (String.Concat xs ys))

// Concatenates a list of strings
// (String.Flatten a:(List String)) : String
(String.Flatten Nil)         = String.nil
(String.Flatten (Cons x xs)) = (String.Concat x (String.Flatten xs))

// Returns true if two strings are equal
// (String.Equal (List String) (List String)) : U60
(String.Equal String.nil         String.nil)         = 1
(String.Equal (String.cons x xs) (String.cons y ys)) = (& (== x y) (String.Equal xs ys))
(String.Equal xs             ys)             = 0

// Todo: improve this
// (String.Hash String) : String
(String.Hash str) = (String.Hash.Go str 0)
  (String.Hash.Go String.nil         hash) = hash
  (String.Hash.Go (String.cons x xs) hash) = (String.Hash.Go xs (+ (- (<< hash 5) hash) x))

// (String.IsEmpty String) : U60
(String.IsEmpty String.nil) = 1
(String.IsEmpty (String.cons x xs)) = 0

// String.Map
(String.Map String.nil fn)         = String.nil
(String.Map (String.cons x xs) fn) = (String.cons (fn x) (String.Map xs fn))

// String.Join
(String.Join Nil          sep) = ""
(String.Join (Cons x Nil) sep) = x
(String.Join (Cons x xs)  sep) = (String.Flatten [x sep (String.Join xs sep)])



// Map
// ===

//type U60Map <A: Type> {
  //empty
  //value(val: A),
  //branch(lft: U60Map<A>, rgt: U60Map<A>),
//}

(Len Empty)           = 0
(Len (Entry val))     = 1
(Len (Nodes lft rgt)) = (+ (Len lft) (Len rgt))

// (Got (Tree a) U60) : (Pair Tree (Maybe a))
(Got tree key) = (Got.Go 32 tree key (λx x))
  (Got.Go n Empty            key self)  = (Pair (self Empty) None)
  (Got.Go n (Entry val)      key self)  = (Pair (self (Entry val)) (Some val))
  (Got.Go n (Nodes lft rgt)  key self)  = (Got.Go.Nodes (& (>> key (- n 1)) 1) (- n 1) key lft rgt self)
    (Got.Go.Nodes 0 n key lft rgt self) = (Got.Go n lft key λx(self (Nodes x rgt)))
    (Got.Go.Nodes 1 n key lft rgt self) = (Got.Go n rgt key λx(self (Nodes lft x)))

(Del tree key) = (Del.Go 32 tree key)
  (Del.Go n (Nodes lft rgt) key)  = (Del.Go.Nodes (& (>> key (- n 1)) 1) (- n 1) lft rgt key)
    (Del.Go.Nodes 0 n lft rgt key) = (Nodes (Del.Go n lft key) rgt)
    (Del.Go.Nodes 1 n lft rgt key) = (Nodes lft (Del.Go n rgt key))
  (Del.Go n tree key)             = Empty

(Set tree key val) = (Set.Go 32 tree key val)
  (Set.Go 0 tree             key val)  = (Entry val)
  (Set.Go n Empty            key val)  = (Set.Go.Empty (& (>> key (- n 1)) 1) (- n 1) key val)
    (Set.Go.Empty 0 n key         val) = (Nodes (Set.Go n Empty key val) Empty)
    (Set.Go.Empty 1 n key         val) = (Nodes Empty (Set.Go n Empty key val))
  (Set.Go n (Nodes lft rgt)  key val)  = (Set.Go.Nodes (& (>> key (- n 1)) 1) (- n 1) key lft rgt val)
    (Set.Go.Nodes 0 n key lft rgt val) = (Nodes (Set.Go n lft key val) rgt)
    (Set.Go.Nodes 1 n key lft rgt val) = (Nodes lft (Set.Go n rgt key val))

(Mut tree key fun) = (Mut.Go 32 tree key fun)
  (Mut.Go 0 (Entry x)         key fun) = (Entry (fun x))
  (Mut.Go 0 tree              key fun) = tree
  (Mut.Go n Empty             key fun) = (Mut.Go.Empty (& (>> key (- n 1)) 1) (- n 1) key fun)
    (Mut.Go.Empty 0 n key         fun) = (Nodes (Mut.Go n Empty key fun) Empty)
    (Mut.Go.Empty 1 n key         fun) = (Nodes Empty (Mut.Go n Empty key fun))
  (Mut.Go n (Nodes lft rgt)   key fun) = (Mut.Go.Nodes (& (>> key (- n 1)) 1) (- n 1) key lft rgt fun)
    (Mut.Go.Nodes 0 n key lft rgt fun) = (Nodes (Mut.Go n lft key fun) rgt)
    (Mut.Go.Nodes 1 n key lft rgt fun) = (Nodes lft (Mut.Go n rgt key fun))

(List.ToMap list) = (List.ToMap.Go list Empty)
  (List.ToMap.Go (Cons (Pair key val) xs) map) = (List.ToMap.Go xs (Set map key val))
  (List.ToMap.Go Nil                      map) = map

(Map.ToList val) = ((Map.ToList.Go val 0) Nil)
  (Map.ToList.Go Empty           key) = λx x
  (Map.ToList.Go (Entry val)     key) = λx (Cons (Pair key val) x)
  (Map.ToList.Go (Nodes lft rgt) key) = λx ((Map.ToList.Go lft (* key 2)) ((Map.ToList.Go rgt (+ (* key 2) 1)) x))

(Map.Values val) = ((Map.Values.Go val) Nil)
  (Map.Values.Go Empty          ) = λx x
  (Map.Values.Go (Entry val)    ) = λx (Cons val x)
  (Map.Values.Go (Nodes lft rgt)) = λx ((Map.Values.Go lft) ((Map.Values.Go rgt) x))


// #############################################################################
// # Parser Combinators                                                        #
// #############################################################################



// Parser
// ======

// Code : Type
// Code = String

// Answer : Type -> Type
// Answer A = Parsed Code A | Failed String

// Parser : Type -> Type
// Parser A = Code -> Answer A

// (IsNameChar Char) : U60
(IsNameChar chr) =
  let is_letter = (| (& (<= 'a' chr) (<= chr 'z')) (& (<= 'A' chr) (<= chr 'Z')))
  let is_number = (& (<= '0' chr) (<= chr '9'))
  let is_symbol = (| (== '_' chr) (== '.' chr))
  (| is_letter (| is_number is_symbol))

// (IsUpper Char) : U60
(IsUpper chr) =
  (& (<= 'A' chr) (<= chr 'Z'))

// (IsLower Char) : U60
(IsLower chr) =
  (& (<= 'a' chr) (<= chr 'z'))

// (IsNumeric Char) : U60
(IsNumeric chr) =
  (& (<= '0' chr) (<= chr '9'))

// (IsOperator Char) : U60
(IsOperator chr) =
  (| (== '+' chr)
  (| (== '-' chr)
  (| (== '*' chr)
  (| (== '/' chr)
  (| (== '%' chr)
  (| (== '&' chr)
  (| (== '|' chr)
  (| (== '^' chr)
  (| (== '<' chr)
  (| (== '>' chr)
  (| (== '=' chr)
  (| (== '!' chr)
     0))))))))))))

// (Bind a_parser:(Parser a) b_parser:(∀a (Parser B))) : (Parser B)
(Bind a_parser b_parser) = λcode (Bind.Go b_parser (a_parser code))
  (Bind.Go b_parser (Parsed code a_val)) = (b_parser a_val code)
  (Bind.Go b_parser (Failed err))        = (Failed err)

// (Done val:a) : (Parser a)
(Done value) = λcode (Parsed code value)

// (IsSpace Char) : U60
(IsSpace chr) = (| (== 10 chr) (== ' ' chr))

// (ParseOne) : (Parser U60)
(ParseOne) = λcode (ParseOne.Go code)
  (ParseOne.Go (String.cons x xs)) = (Parsed xs x)
  (ParseOne.Go String.nil)         = (Parsed String.nil 0)

// (GetName String) : (Pair code:String name:String)
(GetName) = λcode (GetName.Go code)
  (GetName.Go String.nil)                 = (Pair String.nil String.nil)
  (GetName.Go (String.cons head tail))    = (GetName_1 (IsNameChar head) head tail)
    (GetName_1 0 head tail)           = (Pair (String.cons head tail) String.nil)
    (GetName_1 1 head tail)           = (GetName_2 head (GetName.Go tail))
    (GetName_2 head (Pair code name)) = (Pair code (String.cons head name))

// (Matcher text:String) : (Parser Bool)
(Matcher consume text) = λcode (Matcher.Go text code consume λx(x))
  (Matcher.Go Nil         ys             consume redo) = (Parsed ((If consume λx(x) redo) ys) True)
  (Matcher.Go (Cons x xs) String.nil         consume redo) = (Parsed (redo String.nil) False)
  (Matcher.Go (Cons x xs) (String.cons y ys) consume redo) = (MatcherTest (x y) xs y ys consume redo)
    (MatcherTest 0 xs y ys consume redo) = (Parsed (redo (String.cons y ys)) False)
    (MatcherTest 1 xs y ys consume redo) = (Matcher.Go xs ys consume λk(redo (String.cons y k)))

// (TextComparer String) : (∀Char Bool)
(TextComparer String.nil)         = Nil
(TextComparer (String.cons x xs)) = (Cons λc(== x c) (TextComparer xs))

// (PeekCondsHere conds:(∀Char Bool)) : (Parser Bool)
(PeekCondsHere conds) = λcode ((Matcher False conds) code)

//// (PeekConds conds:(∀Char Bool)) : (Parser Bool)
(PeekConds conds) = λcode ((Matcher False conds) (Skipper code))

// (PeekTextHere text:String) : (Parser Bool)
(PeekTextHere text) = λcode ((Matcher False (TextComparer text)) code)

// (PeekText text:String) : (Parser Bool)
(PeekText text) = λcode ((Matcher False (TextComparer text)) (Skipper code))

// (MatchCondsHere conds:(∀Char Bool)) : (Parser Bool)
(MatchCondsHere conds) = λcode ((Matcher True conds) code)

// (MatchConds conds:(∀Char Bool)) : (Parser Bool)
(MatchConds conds) = λcode ((Matcher True conds) (Skipper code))

// (MatchTextHere text:String) : (Parser Bool)
(MatchTextHere text) = λcode ((Matcher True (TextComparer text)) code)

// (MatchText text:String) : (Parser Bool)
(MatchText text) = λcode ((Matcher True (TextComparer text)) (Skipper code))

// (TestChar cond:(∀Char Bool)) : (Parser Bool)
(TestChar cond) = λcode ((TestCharHere cond) (Skipper code))

// (ParseTextHere text:String) : (Parser Unit)
(ParseTextHere text)      = (Bind (MatchTextHere text) λgot(ParseTextHereGot got))
  (ParseTextHereGot False) = λcode (Failed "Syntax error.") // TODO: show expected
  (ParseTextHereGot True)  = (Done Unit)

// (ParseText text:String) : (Parser Unit)
(ParseText text) = λcode ((ParseTextHere text) (Skipper code))

// Skips spaces and comments
// (Skipper String) : String
(Skipper String.nil)         = String.nil
(Skipper (String.cons x xs)) = (Skipper.Go (IsSpace x) (== x '/') x xs)

  (Skipper.Go 0 0 x xs)   = (String.cons x xs)
  (Skipper.Go 1 c x xs)   = (Skipper xs)
  (Skipper.Go s 1 x xs)   = (Skipper.DropComment xs)

  (Skipper.DropComment String.nil)         = String.nil
  (Skipper.DropComment (String.cons x xs)) = (Skipper.DropComment.Go (== x 10) x xs) 
    
    (Skipper.DropComment.Go 1 x xs) = (Skipper xs)
    (Skipper.DropComment.Go 0 x xs) = (Skipper.DropComment xs)

// (ParseNameHere) : (Parser String)
ParseNameHere                        = λcode (ParseNameHere_0 ((GetName) code))
  (ParseNameHere_0 (Pair code name)) = (Parsed code name)

// (ParseName) : (Parser String)
ParseName = λcode ((ParseNameHere) (Skipper code))

// (ParseEnd) : (Parser Bool)
ParseEnd = λcode (ParseEnd.Go code)
  (ParseEnd.Go String.nil)         = (Parsed Nil True)
  (ParseEnd.Go (String.cons x xs)) = (Parsed (String.cons x xs) False)

// Parses until a stop condition is true.
// (ParseUntil stop:(Parser Bool) parser:(Parser a) ) : (Parser (List a))
(ParseUntil stop parser) = (Bind stop λs (ParseUntil.Go s stop parser))
  (ParseUntil.Go False stop parser) =
    (Bind parser                   λhead 
    (Bind (ParseUntil stop parser) λtail 
    (Done (Cons head tail))))
  (ParseUntil.Go True stop parser) =
    (Done Nil)

// (Grammar choices:(List (Parser (Maybe a)))) : (Parser a)
(Grammar Nil)                                     = λcode (Failed "<TODO>")
(Grammar (Cons choice choices))                   = λcode (Grammar_0 (choice code) choices)
  (Grammar_0 (Failed err)                choices) = (Failed err)
  (Grammar_0 (Parsed code None)          choices) = ((Grammar choices) code)
  (Grammar_0 (Parsed code (Some result)) choices) = (Parsed code result)

// Note: unlike Rust's version, this won't rollback
// (Guard head:(Parser Bool) body:(Parser a)) : (Parser (Maybe a))
(Guard head body) = λcode (Guard_0 (head code) body)
  (Guard_0 (Failed err)          body) = (Failed err)
  (Guard_0 (Parsed code False)   body) = (Parsed code None)
  (Guard_0 (Parsed code True)    body) = ((Bind body λgot(Done (Some got))) code)



// #############################################################################
// # Kind2                                                                     #
// #############################################################################



// Parsing
// -------

// (ParseVar) : (Parser (Maybe Term))
(ParseVar) =
  (Bind (MatchText "-") λeras
  (Bind ParseName       λname
  (ParseVar.0 eras name)))

  (ParseVar.0 eras String.nil)         = (Done None)
  (ParseVar.0 eras (String.cons x xs)) = (ParseVar.1
    eras
    (String.Equal (String.cons x xs) "Type")
    (String.Equal (String.cons x xs) "U60")
    (IsUpper x)
    (IsNumeric x)
    (String.cons x xs))

  (ParseVar.1 eras 1 _ _ _ str) = (Done (Some Typ))
  (ParseVar.1 eras _ 1 _ _ str) = (Done (Some U60))
  (ParseVar.1 eras _ _ 1 _ str) = (Done (Some (Cts (Name.Make str) [])))
  (ParseVar.1 eras _ _ _ 1 str) = (Done (Some (N32 (U60.Read str))))
  (ParseVar.1 eras _ _ _ _ str) = (Bind (MatchText ":") λis_ann (ParseVar.2 eras (If is_ann 1 _) str))

  (ParseVar.2 eras 1 str) = (Bind ParseTerm λterm (Done (Some (Ann eras (Var (Name.Make str)) term))))
  (ParseVar.2 eras 0 str) = (Done (Some (Var (Name.Make str))))

// (ParseGol) : (Parse (Maybe Term))
(ParseGol) = (Guard (MatchText "?")
  (Bind ParseName λname
  (Done (Gol name))))

// (ParseDef) : (Parser (Maybe Term))
(ParseDef) = (Guard (MatchText "def ")
  (Bind ParseName       λname
  (Bind (MatchText ":") λanns
  (ParseDefAnn anns name))))
(ParseDefAnn True name) =
  (Bind ParseTerm       λtype
  (Bind (ParseText "=") λskip
  (Bind ParseTerm       λexpr
  (Bind ParseTerm       λbody
  (Done (Def (Name.Make name) (Ann False expr type) body))))))
(ParseDefAnn False name) =
  (Bind (ParseText "=") λskip
  (Bind ParseTerm       λexpr
  (Bind ParseTerm       λbody
  (Done (Def (Name.Make name) expr body)))))

// (ParseLet) : (Parser (Maybe Term))
(ParseLet) = (Guard (MatchText "let ")
  (Bind ParseName       λname
  (Bind (MatchText ":") λanns
  (ParseLetAnn anns name))))
(ParseLetAnn True name) =
  (Bind ParseTerm       λtype
  (Bind (ParseText "=") λskip
  (Bind ParseTerm       λexpr
  (Bind ParseTerm       λbody
  (Done (Let (Name.Make name) (Ann False expr type) body))))))
(ParseLetAnn False name) =
  (Bind (ParseText "=") λskip
  (Bind ParseTerm       λexpr
  (Bind ParseTerm       λbody
  (Done (Let (Name.Make name) expr body)))))

// (ParseAll) : (Parse (Maybe Term))
(ParseAll) = (Guard (MatchText "∀")
  (Bind (ParseText "(")  λskip
  (Bind ParseName        λname
  (Bind (ParseText ":")  λskip
  (Bind ParseTerm        λtype
  (Bind (ParseText ")")  λskip
  (Bind ParseTerm        λbody
  (Done (All (Name.Make name) type body)))))))))

// (ParseLam) : (Parser (Maybe Term))
(ParseLam) = (Guard (MatchText "λ")
  (Bind ParseName λname
  (Bind ParseTerm λbody
  (Done (Lam (Name.Make name) body)))))

// (ParseApp) : (Parser (Maybe Term)) 
(ParseApp) = (Guard (MatchText "(")
  (Bind ParseTerm                              λfunc
  (Bind (ParseUntil (MatchText ")") ParseTerm) λargs
  (Done ((List.Fold args λx(x) λxλtλf(t (App f x))) func)))))

// (ParseCts) : (Parser (Maybe Term)) 
(ParseCts) = (Guard (PeekConds [λx(== x '(') λx(IsUpper x)])
  (Bind (ParseText "(")                        λskip
  (Bind ParseName                              λname
  (Bind (ParseUntil (MatchText ")") ParseTerm) λargs
  (Done (Cts (Name.Make name) args))))))

// (ParseO32) : (Parser (Maybe Term)) 
(ParseO32) = (Guard (PeekConds [λx(== x '(') λx(IsOperator x)])
  (Bind (ParseText "(") λskip
  (Bind ParseOper λoper
  (Bind ParseTerm λval0
  (Bind ParseTerm λval1
  (Bind (ParseText ")") λskip
  (Done (O32 oper val0 val1))))))))

// (ParseChr) : (Parser (Maybe Term))
(ParseChr) = (Guard (MatchText "'")
  (Bind ParseOne        λchr
  (Bind (ParseText "'") λskp
  (Done (N32 chr)))))

// (ParseStr) : (Parser (Maybe Term))
(ParseStr) = (Guard (MatchText (String.cons '"' String.nil))
  (Bind (ParseUntil (MatchText (String.cons '"' String.nil)) ParseOne) λchars
  (Done (ParseStr.Make chars))))

(ParseStr.Make (Cons x xs)) = (Cts (Name.Make "String.cons") [(N32 x) (ParseStr.Make xs)])
(ParseStr.Make Nil)         = (Cts (Name.Make "String.nil") [])

(ParseOper) = (Grammar [
  (Guard (MatchTextHere "+")  (Done ADD))
  (Guard (MatchTextHere "-")  (Done SUB))
  (Guard (MatchTextHere "*")  (Done MUL))
  (Guard (MatchTextHere "/")  (Done DIV))
  (Guard (MatchTextHere "%")  (Done MOD))
  (Guard (MatchTextHere "&")  (Done AND))
  (Guard (MatchTextHere "|")  (Done OR))
  (Guard (MatchTextHere "^")  (Done XOR))
  (Guard (MatchTextHere "<<") (Done SHL))
  (Guard (MatchTextHere ">>") (Done SHR))
  (Guard (MatchTextHere "<=") (Done LTE))
  (Guard (MatchTextHere "<")  (Done LTN))
  (Guard (MatchTextHere "==") (Done EQL))
  (Guard (MatchTextHere ">=") (Done GTE))
  (Guard (MatchTextHere ">")  (Done GTN))
  (Guard (MatchTextHere "!=") (Done NEQ))
  (Done (Some ADD)) // FIXME?
])

//rewrite x with e in goal
// (ParseRwt) : (Parser (Maybe Term))
(ParseRwt) = (Guard (MatchText "rewrite ")
  (Bind ParseName          λname
  (Bind (ParseText "with") λskip
  (Bind ParseTerm          λwitn
  (Bind (ParseText "in")   λskip
  (Bind ParseTerm          λgoal
  (Bind ParseTerm          λexpr
  (Done (Rwt (Name.Make name) witn goal expr)))))))))

// (ParseAnnEql) : (Parser (Maybe Term))
(ParseAnnEql) = (Guard (MatchText "{")
  (Bind ParseTerm        λval0
  (Bind (MatchText "::") λanns
  (ParseAnnEqlGo anns val0))))
(ParseAnnEqlGo True val0) =
  (Bind ParseTerm       λval1
  (Bind (ParseText "}") λskip
  (Done (Ann False val0 val1))))
(ParseAnnEqlGo False val0) =
  (Bind (ParseText "==") λskip
  (Bind ParseTerm        λval1
  (Bind (ParseText "}")  λskip
  (Done (Eql val0 val1)))))

// (ParseRfl) : (Parser (Maybe Term))
(ParseRfl) = (Guard (MatchText "refl ")
  (Bind ParseTerm λexpr
  (Done (Rfl expr))))

// TODO: assign unique hashes automatically
// (ParseHol) : (Parser (Maybe Term))
(ParseHol) = (Guard (MatchText "_")
  (Bind ParseName λname
  (Done (Hol (String.Hash name)))))

// (ParseTerm) : (Parser Term)
(ParseTerm) =

  (Bind ParseTerm.Ini λini
  (Bind ParseTerm.End λend
  (Done (end ini))))

  (ParseTerm.Ini) = (Grammar [
    ParseDef,
    ParseLet,
    ParseCts,
    ParseO32,
    ParseAll,
    ParseLam,
    ParseApp,
    ParseChr,
    ParseStr,
    ParseGol,
    ParseRfl,
    ParseRwt,
    ParseAnnEql,
    ParseHol,
    ParseVar,
  ])

  (ParseTerm.End) = (Grammar [
    //(ParseAnn)
    //(ParseEql)
    (Done (Some λx(x)))
  ])

// (ParseDecl) : (Parser Decl)
(ParseDecl) =
  (Bind ParseTerm       λlhs
  (Bind (MatchText ":") λtyp
  (ParseDecl_rhs typ lhs)))
(ParseDecl_rhs True lhs) = 
  (Bind ParseTerm λrhs
  (Done (DefType lhs rhs)))
(ParseDecl_rhs False lhs) =
  (Bind (ParseText "=") λskp
  (Bind ParseTerm       λrhs
  (Done (DefRule lhs rhs))))

// (ParseDecls) : (Parser (List Decl))
(ParseDecls) = (ParseUntil
  λcode((ParseEnd) (Skipper code))
  ParseDecl)

// (Term.Read File String) : Term
(Term.Read file code) = (Term.Read.Got ((ParseTerm) code))
  (Term.Read.Got (Parsed code term)) = term
  (Term.Read.Got (Failed err))       = (Var (String.Concat "[ParseError] " err))

// (File.Read String) : (Result File)
(File.Read code) = (File.Read.Got ((ParseDecls) code))
  (File.Read.Got (Parsed code decls)) = (Ok (File.Make decls))
  (File.Read.Got (Failed err))        = (Er (String.Concat "[ParseError] " err))


// Post-parse helpers
// ------------------

// Used for parse-time subst (def), NOT by the evaluator/checker!
// Assumes the defined expression has no free variables.
// (Def String Term Term) : Term
(Def nm val (Var name))                = (U60.If (Name.Equal name nm) val (Var name))
(Def nm val (Hol hash))                = (Hol hash)
(Def nm val Typ)                       = Typ
(Def nm val U60)                       = U60
(Def nm val (N32 numb))                = (N32 numb)
(Def nm val (O32 oper val0 val1))      = (O32 oper (Def nm val val0) (Def nm val val1))
(Def nm val (Gol name))                = (Gol name)
(Def nm val (Ann eras xval xtyp))      = (Ann eras (Def nm val xval) (Def nm val xtyp))
(Def nm val (Let name expr body))      = (Let name (Def nm val expr) (Def.Body nm val name body))
(Def nm val (All name type body))      = (All name (Def nm val type) (Def.Body nm val name body))
(Def nm val (Lam name body))           = (Lam name (Def.Body nm val name body))
(Def nm val (App func argm))           = (App (Def nm val func) (Def nm val argm))
(Def nm val (Cts ctid args))           = (Cts ctid (Def.Many nm val args))
(Def nm val (Eql val0 val1))           = (Eql (Def nm val val0) (Def nm val val1))
(Def nm val (Rfl expr))                = (Rfl (Def nm val expr))
(Def nm val (Rwt name witn goal expr)) = (Rwt name (Def nm val witn) (Def.Body nm val name goal) (Def nm val expr))

(Def.Many nm val Nil)         = Nil
(Def.Many nm val (Cons x xs)) = (Cons (Def nm val x) (Def.Many nm val xs))

// (Def.Body String Term String Term) : Term
(Def.Body nm val name body) = (Def.Body.Go (Name.Equal nm name) nm val body)
  (Def.Body.Go 0 nm val body) = (Def nm val body)
  (Def.Body.Go 1 nm val body) = body



// Utils
// -----

// (Ctr.GetId Term) : U60
(Ctr.GetId (Cts ctid args)) = ctid
(Ctr.GetId term)            = (Name.Make "?")

// (Ctr.GetArgs Term) : (List Term)
(Ctr.GetArgs (Cts ctid args)) = args
(Ctr.GetArgs term)            = [] 

(N32.GetValue (N32 value)) = value
(N32.GetValue term)        = 0

(Ann.IsErased (Ann eras expr type)) = eras
(Ann.IsErased term)                 = False

(Var.GetName (Var name)) = name
(Var.GetName x)          = (Name.Make "_")

(Arg.Get (Ann eras var expr) cont) = (cont (Var.GetName var) expr)
(Arg.Get term                cont) = (cont (Name.Make "_") term)



// File
// ----

// type Decl {
//   DefType(lhs:Term, rhs:Term)
//   DefRule(lhs:LHS, rhs:Term)
// }

// type Type {
//   lhs: Term
//   rhs: Term
// }

// type Rule {
//   lhs: Term
//   rhs: Term
// }

// type Func {
//   lty: Term
//   rty: Term
//   rules: List<Rule>
// }

// type File {
//   funs: Map<Func>
// }

(Rule.Push lhs rhs (Rule r_lhs r_rhs r_rules)) = (Rule r_lhs r_rhs (Rule.Push lhs rhs r_rules))
(Rule.Push lhs rhs End)                        = (Rule lhs rhs End)

// FIXME: this should be replaced by proper user of Maybe
// FuncEmpty : Func
FuncEmpty = (Func (Var (Name.Make "?")) (Var (Name.Make "?")) End)

// (FuncSetType func:Func new_type:Type) : Func
(FuncSetType (Func lty rty rules) new_lty new_rty) = (Func new_lty new_rty rules)

// (FuncSetType func:Func lhs:Term rhs:Term) : Func
(FuncAddRule (Func lty rty rules) lhs rhs) = (Func lty rty (Rule.Push lhs rhs rules))

// (Func.GetName func:Func file:File) : Func
(Func.GetName (Func lty rty rules) file) = (Name.GetString (Ctr.GetId lty))

// (Func.Get func:Func ...) : ...
(Func.Get (Func lty rty rules) cont) = (cont lty rty rules)

// (Func.GetInputType func:Func ...) : ...
(Func.GetInputType (Func lty rty rules)) = lty

// (Func.GetOutputType func:Func ...) : ...
(Func.GetInputType (Func lty rty rules)) = rty

// (Func.GetRules func:Func ...) : ...
(Func.GetRules (Func lty rty rules)) = rules

// (File.Make (List Decl)) : File
(File.Make decls) = (File (File.Make.Go decls Empty))

  (File.Make.Go (Cons (DefType lhs rhs) decls) file) =
    let ctid = (Ctr.GetId lhs)
    let func = (Func lhs rhs End)
    (File.Make.Go decls (Set file (Name.GetHash ctid) func))

  (File.Make.Go (Cons (DefRule lhs rhs) decls) file) =
    let ctid = (Ctr.GetId lhs)
    let func = λfunc (FuncAddRule func (File.Make.LHS lhs rhs) rhs)
    (File.Make.Go decls (Mut file (Name.GetHash ctid) func))

  (File.Make.Go Nil file) = file

  // Builds the left-hand side of a rule, annotating variable usage counts.
  // TODO: use different constructor names
  // FIXME: is this really needed? benchmark without
  // (File.Make.LHS Term Term) : Term
  (File.Make.LHS (Var name)      rhs) = (Use name (Uses name rhs))
  (File.Make.LHS (N32 numb)      rhs) = (N32 numb)
  (File.Make.LHS (Cts ctid args) rhs) = (Cts ctid (File.Make.LHS.Many args rhs))
  (File.Make.LHS (Rlf expr)      rhs) = (Rlf (File.Make.LHS expr rhs))
  (File.Make.LHS term            rhs) = term

  (File.Make.LHS.Many Nil         rhs) = Nil
  (File.Make.LHS.Many (Cons x xs) rhs) = (Cons (File.Make.LHS x rhs) (File.Make.LHS.Many xs rhs))

// (File.GetFuncs File) : (Map Func)
(File.GetFuncs (File funs)) = funs

// (File.GotFunc File U60) : (Pair File (Maybe Func))
(File.GotFunc (File funs) ctid) =
  (Pair.Get (Got funs (Name.GetHash ctid)) λfuns λgot
  (Pair (File funs) got))

// (File.GetFunc File U60) : (Maybe Func)
(File.GetFunc (File funs) ctid) =
  (Pair.Snd (Got funs (Name.GetHash ctid)))

// (File.IsCtr File U60) : Bool
(File.IsCtr (File funs) ctid) =
  (Pair.Get (Got funs (Name.GetHash ctid)) λfuns λgot
  (Maybe.Case got 1 λfunc(File.IsCtr.Func func)))

  (File.IsCtr.Func (Func lty rty End))                  = 1
  (File.IsCtr.Func (Func lty rty (Rule lhs rhs rules))) = 0

// Stringifying
// ------------

(String.Show.Go xs) =
  λx(String.Concat xs x)

// (Term.Show term:Term file:File) : String
(Term.Show file term) = ((Term.Show.Go term file) "")
  (Term.Show.Go (Var name) file) =
    λx((String.Show.Go (Name.GetString name))
      x)
  (Term.Show.Go (Use name uses) file) =
    λx((String.Show.Go (Name.GetString name))
      x)
  (Term.Show.Go (Hol hash) file) =
    λx((String.Show.Go "_")
      ((String.Show.Go (U60.Show hash))
      x))
  (Term.Show.Go (Let name expr body) file) =
    λx((String.Show.Go "let ")
      ((String.Show.Go (Name.GetString name))
      ((String.Show.Go " = ")
      ((Term.Show.Go expr file)
      ((String.Show.Go "; ")
      ((Term.Show.Go body file)
      x))))))
  (Term.Show.Go (Ann eras xval xtyp) file) =
    λx((String.Show.Go "(")
      ((Term.Show.Go xval file)
      ((String.Show.Go " :: ")
      ((Term.Show.Go xtyp file)
      ((String.Show.Go ")")
      x)))))
  (Term.Show.Go Typ file) =
    λx((String.Show.Go "Type")
      x)
  (Term.Show.Go U60 file) =
    λx((String.Show.Go "U60")
      x)
  (Term.Show.Go (N32 numb) file) =
    λx((String.Show.Go (U60.Show numb))
      x)
  (Term.Show.Go (O32 oper val0 val1) file) =
    λx((String.Show.Go "(")
      ((Oper.Show.Go oper)
      ((String.Show.Go " ")
      ((Term.Show.Go val0 file)
      ((String.Show.Go " ")
      ((Term.Show.Go val1 file)
      ((String.Show.Go ")")
      x)))))))
  (Term.Show.Go (Gol name) file) =
    λx((String.Show.Go "?")
      ((String.Show.Go name)
      x))
  (Term.Show.Go (All name type body) file) =
    λx((String.Show.Go "∀(")
      ((String.Show.Go (Name.GetString name))
      ((String.Show.Go ": ")
      ((Term.Show.Go type file)
      ((String.Show.Go ") ")
      ((Term.Show.Go body file)
      x))))))
  (Term.Show.Go (Lam name body) file) =
    λx((String.Show.Go "λ")
      ((String.Show.Go (Name.GetString name))
      ((String.Show.Go " ")
      ((Term.Show.Go body file)
      x))))
  (Term.Show.Go (App func argm) file) =
    λx((String.Show.Go "(")
      ((Term.Show.Go func file)
      ((String.Show.Go " ")
      ((Term.Show.Go argm file)
      ((String.Show.Go ")")
      x)))))
  (Term.Show.Go (Cts ctid args) file) =
    λx((String.Show.Go "(")
      ((String.Show.Go (Name.GetString ctid))
      ((Term.Show.Go.Cts.Args args file)
      ((String.Show.Go ")")
      x))))
  (Term.Show.Go (Eql val0 val1) file) =
    λx((Term.Show.Go val0 file)
      ((String.Show.Go " == ")
      ((Term.Show.Go val1 file)
      x)))
  (Term.Show.Go (Rfl expr) file) =
    λx((String.Show.Go "refl ")
      ((Term.Show.Go expr file)
      x))
  (Term.Show.Go (Rwt name witn goal expr) file) =
    λx((String.Show.Go "rewrite ")
      ((String.Show.Go (Name.GetString name))
      ((String.Show.Go "with ")
      ((Term.Show.Go witn file)
      ((String.Show.Go "in ")
      ((Term.Show.Go goal file)
      ((String.Show.Go " ")
      ((Term.Show.Go expr file)
      x))))))))
  (Term.Show.Go.Cts.Args Nil file) =
    λx(x)
  (Term.Show.Go.Cts.Args (Cons arg args) file) =
    λx((String.Show.Go " ")
      ((Term.Show.Go arg file)
      ((Term.Show.Go.Cts.Args args file)
      x)))

(Oper.Show.Go ADD) = (String.Show.Go "+")
(Oper.Show.Go SUB) = (String.Show.Go "-")
(Oper.Show.Go MUL) = (String.Show.Go "*")
(Oper.Show.Go DIV) = (String.Show.Go "/")
(Oper.Show.Go MOD) = (String.Show.Go "%")
(Oper.Show.Go AND) = (String.Show.Go "&")
(Oper.Show.Go OR)  = (String.Show.Go "|")
(Oper.Show.Go XOR) = (String.Show.Go "^")
(Oper.Show.Go SHL) = (String.Show.Go "<<")
(Oper.Show.Go SHR) = (String.Show.Go ">>")
(Oper.Show.Go LTN) = (String.Show.Go "<")
(Oper.Show.Go LTE) = (String.Show.Go "<=")
(Oper.Show.Go EQL) = (String.Show.Go "==")
(Oper.Show.Go GTE) = (String.Show.Go ">=")
(Oper.Show.Go GTN) = (String.Show.Go ">")
(Oper.Show.Go NEQ) = (String.Show.Go "!=")

(Context.Show Nil file) = ""
(Context.Show ctx file) =
  let ctx = (List.Reverse ctx)
  let build = λz
    ((String.Show.Go "Context:")
    ((String.Show.Go NewLine)
    ((Context.Show.Go ctx file)
      z)))
  (build "")

  (Context.Show.Go Nil file) = λz(z)
  (Context.Show.Go (Cons (Pair name type) rest) file) =
    λz((String.Show.Go "- ")
      ((String.Show.Go (Name.GetString name))
      ((String.Show.Go " : ") 
      ((Term.Show.Go type file)
      ((String.Show.Go NewLine)
      ((Context.Show.Go rest file)
      z))))))

(File.Show file) = ((File.Show.Go (Map.Values (File.GetFuncs file)) file) "")
  (File.Show.Go Nil file) =
    λz(z)
  (File.Show.Go (Cons (Func lhs.t lhs.r rules) funs) file) =
    λz((Term.Show.Go lhs.t file)
      ((String.Show.Go " : ")
      ((Term.Show.Go lhs.r file)
      ((String.Show.Go NewLine)
      ((Rules.Show.Go rules file)
      ((String.Show.Go NewLine)
      ((File.Show.Go funs file)
      z)))))))
  (Rules.Show.Go End file) =
    λx(x)
  (Rules.Show.Go (Rule lhs rhs rules) file) =
    λx((Term.Show.Go lhs file)
      ((String.Show.Go " = ")
      ((Term.Show.Go rhs file)
      ((String.Show.Go NewLine)
      ((Rules.Show.Go rules file)
      x)))))

// Evaluation
// ----------

// Counts free occurrences of a name
// (Uses String Term) : U60
(Uses nm (Var name))                = (Name.Equal name nm)
(Uses nm (Use name numb))           = (Name.Equal name nm)
(Uses nm (Hol hash))                = 0
(Uses nm Typ)                       = 0
(Uses nm U60)                       = 0
(Uses nm (N32 numb))                = 0
(Uses nm (O32 oper val0 val1))      = (+ (Uses nm val0) (Uses nm val1))
(Uses nm (Gol name))                = 0
(Uses nm (Ann eras xval xtyp))      = (Uses nm xval)
(Uses nm (Let name expr body))      = (+ (Uses nm expr) (Uses.Shadow (Name.Equal nm name) nm body))
(Uses nm (All name type body))      = (+ (Uses nm type) (Uses.Shadow (Name.Equal nm name) nm body))
(Uses nm (Lam name body))           = (Uses.Shadow (Name.Equal nm name) nm body)
(Uses nm (App func argm))           = (+ (Uses nm func) (Uses nm argm))
(Uses nm (Cts ctid args))           = (Uses.Many nm args)
(Uses nm (Eql val0 val1))           = (+ (Uses nm val0) (Uses nm val1))
(Uses nm (Rfl expr))                = (Uses nm expr)
(Uses nm (Rwt name witn goal expr)) = (+ (Uses nm witn) (+ (Uses.Shadow (Name.Equal nm name) nm goal) (Uses nm expr)))
(Uses.Many nm Nil)                  = 0
(Uses.Many nm (Cons x xs))          = (+ (Uses nm x) (Uses.Many nm xs))
(Uses.Shadow 0 nm body)             = (Uses nm body)
(Uses.Shadow 1 nm body)             = 0

// Appends N copies of a term to a vars context
// (Clone U60 String a (List (Pair String a))) : (List (Pair String a))
(Clone 0 name term ctx) = ctx
(Clone 1 name term ctx) = (Cons (Pair name term) ctx)
(Clone n name term ctx) = (Cons (Pair name term) (Clone (- n 1) name term ctx))

// Appends enough copies of a term to a vars context
(CloneFor body name term ctx) = (Clone (Uses name body) name term ctx)

// Converts a term to high-order
// (High file:File term:Term vars:?) : HTerm
(High file term vars) = (Trip.Get (High.Go term file vars) λfile λvars λterm term)

  // (High.Go file:File term:Term file:File vars:(List (Pair String HTerm))) : (Trip File (List (Pair String HTerm)) HTerm)
  
  (High.Go (Var name) file vars) = (HighFind name file vars)
    (HighFind name file Nil) = (Trip file Nil (HVar name))
    (HighFind name file (Cons (Pair var val) vars)) = (HighFound (Name.Equal name var) name var val file vars)
      (HighFound 1 name var val file vars) = (Trip file vars val)
      (HighFound 0 name var val file vars) =
        (Trip.Get (HighFind name file vars) λfile λvars λgot
        (Trip file (Cons (Pair var val) vars) got))

  (High.Go (Use name count) file vars) =
    //(Trip file vars (HUse name count)) // ???
    (High.Go (Var name) file vars)

  (High.Go (Ann eras xval xtyp) file vars) =
    (High.Go xval file vars)

  (High.Go Typ file vars) =
    (Trip file vars HTyp)

  (High.Go U60 file vars) =
    (Trip file vars HU60)

  (High.Go (N32 numb) file vars) =
    (Trip file vars (HN32 numb))

  (High.Go (O32 oper val0 val1) file vars) =
    (Trip.Get (High.Go val0 file vars) λfile λvars λval0
    (Trip.Get (High.Go val1 file vars) λfile λvars λval1
    (Trip file vars (HOperate oper val0 val1))))

  (High.Go (Gol name) file vars) =
    (Trip file vars (HGol name))

  (High.Go (All name type body) file vars) =
    (Trip.Get (High.Go type file vars) λfile λvars λtype
    (Trip.Get (High.Go body file (CloneFor body name $x vars)) λfile λvars λbody
    (Trip file vars (HAll type λ$x body))))

  (High.Go (Let name expr body) file vars) =
    (Trip.Get (High.Go expr file vars) λfile λvars λexpr
    (Trip.Get (High.Go body file (CloneFor body name expr vars)) λfile λvars λbody
    (Trip file vars body)))

  (High.Go (Lam name body) file vars) =
    (Trip.Get (High.Go body file (CloneFor body name $x vars)) λfile λvars λbody
    (Trip file vars (HLam λ$x body)))

  (High.Go (App func argm) file vars) =
    (Trip.Get (High.Go func file vars) λfile λvars λfunc
    (Trip.Get (High.Go argm file vars) λfile λvars λargm
    (Trip file vars (HApply func argm))))

  (High.Go (Cts ctid args) file vars) =
    (Pair.Get (File.GotFunc file ctid)      λfile λfunc
    (Trip.Get (High.Go.Many args file vars) λfile λvars λargs
    (High.Go.Cts func (HCts ctid args) file vars)))

  (High.Go (Arg name expr) file vars) = 
    (High.Go expr file vars)

  (High.Go (Eql val0 val1) file vars) =
    (Trip.Get (High.Go val0 file vars) λfile λvars λval0
    (Trip.Get (High.Go val1 file vars) λfile λvars λval1
    (Trip file vars (HEql val0 val1))))

  (High.Go (Rfl expr) file vars) =
    (Trip.Get (High.Go expr file vars) λfile λvars λexpr
    (Trip file vars (HRfl expr)))

  (High.Go (Rwt name witn goal expr) file vars) =
    (Trip.Get (High.Go expr file vars) λfile λvars λexpr
    (Trip file vars expr))

    //(Trip.Get (High.Go witn file vars)                         λfile λvars λwitn
    //(Trip.Get (High.Go goal file (CloneFor goal name $x vars)) λfile λvars λgoal
    //(Trip.Get (High.Go expr file vars)                         λfile λvars λexpr
    //(Trip file vars (HRwt name witn λ$x(goal) expr)))))

  (High.Go.Many Nil file vars) =
    (Trip file vars Nil)
  (High.Go.Many (Cons x xs) file vars) =
    (Trip.Get (High.Go x file vars)       λfile λvars λx
    (Trip.Get (High.Go.Many xs file vars) λfile λvars λxs
    (Trip file vars (Cons x xs))))

  (High.Go.Cts None                        term file vars) = (Trip file vars term)
  (High.Go.Cts (Some (Func lty rty rules)) term file vars) = (HFindMatchingRule rules term file vars)

  (High.Go (Hol hash) file vars) =
    (Trip file vars (HHol hash))


// TODO: perhaps linearize term?
// (HFindMatchingRule (List Rule) HTerm File Vars) : HTerm
(HFindMatchingRule End                  term file vars) = (Trip file vars term)
(HFindMatchingRule (Rule lhs rhs rules) term file vars) = (HFindMatchingRule.Found (HMatches.Go lhs term) rhs rules file vars)
  (HFindMatchingRule.Found (Trip lhs term 0) rhs rules file vars) = (HFindMatchingRule rules term file vars)
  (HFindMatchingRule.Found (Trip lhs term 1) rhs rules file vars) = (High.Go rhs file ((HMatch.Go lhs term) vars))

// High-Order pattern-matching

// Tests if a LHS matches with a HTerm.
// Returns the reconstructed terms, and 0/1 if not/yes.
// (HMatches LHS HTerm) : (Trip Term HTerm Bool)
(HMatches x y) = (HMatches.Go x y)

  (HMatches.Chain a b 0 fn cont) = (cont a b 0)
  (HMatches.Chain a b 1 fn cont) = (Trip.Get (fn a b) cont)

  (HMatches.Go (N32 x.numb) (HN32 y.numb)) = (Trip (N32 x.numb) (HN32 y.numb) (== x.numb y.numb))

  (HMatches.Go (Cts x.ctid x.args) (HCts y.ctid y.args)) = (HMatches.Go.Cts (Name.Equal x.ctid y.ctid) x.ctid x.args y.ctid y.args)
    (HMatches.Go.Cts 0 x.ctid x.args y.ctid y.args) = (Trip (Cts x.ctid x.args) (HCts y.ctid y.args) 0)
    (HMatches.Go.Cts 1 x.ctid x.args y.ctid y.args) = (HMatches.Go.Cts.Many x.args y.args 1 x.ctid y.ctid λz(z) λz(z))
      (HMatches.Go.Cts.Many Nil         Nil         m x.ctid y.ctid xs ys) = (Trip (Cts x.ctid (xs Nil)) (HCts y.ctid (ys Nil)) m)
      (HMatches.Go.Cts.Many (Cons a as) (Cons b bs) m x.ctid y.ctid xs ys) =
        (HMatches.Chain a b m λaλb(HMatches.Go a b) λa λb λm
        (HMatches.Go.Cts.Many as bs m x.ctid y.ctid λk(xs (Cons a k)) λk(ys (Cons b k))))

  (HMatches.Go (Use a_name uses) b) =
    (Trip (Use a_name uses) b 1)

  (HMatches.Go a b) =
    (Trip a b 0)

// (HMatch Term HTerm) : (List (Pair String HTerm))
(HMatch x y) = ((HMatch.Go x y) Nil)

  (HMatch.Go (Cts x.ctid x.args) (HCts y.ctid y.args)) = (HMatch.Go.Many x.args y.args)
    (HMatch.Go.Many Nil         Nil        ) = λz (z)
    (HMatch.Go.Many (Cons x xs) (Cons y ys)) = λz ((HMatch.Go x y) ((HMatch.Go.Many xs ys) z))

  (HMatch.Go (Use a_name uses) b) = λz
    (Clone uses a_name b z)

  (HMatch.Go a b) = λz
    z

// High-order operation
(HOperate ADD (HN32 val0) (HN32 val1)) = (HN32 (+  val0 val1))
(HOperate SUB (HN32 val0) (HN32 val1)) = (HN32 (-  val0 val1))
(HOperate MUL (HN32 val0) (HN32 val1)) = (HN32 (*  val0 val1))
(HOperate DIV (HN32 val0) (HN32 val1)) = (HN32 (/  val0 val1))
(HOperate MOD (HN32 val0) (HN32 val1)) = (HN32 (%  val0 val1))
(HOperate AND (HN32 val0) (HN32 val1)) = (HN32 (&  val0 val1))
(HOperate OR  (HN32 val0) (HN32 val1)) = (HN32 (|  val0 val1))
(HOperate XOR (HN32 val0) (HN32 val1)) = (HN32 (^  val0 val1))
(HOperate SHL (HN32 val0) (HN32 val1)) = (HN32 (<< val0 val1))
(HOperate SHR (HN32 val0) (HN32 val1)) = (HN32 (>> val0 val1))
(HOperate LTN (HN32 val0) (HN32 val1)) = (HN32 (<  val0 val1))
(HOperate LTE (HN32 val0) (HN32 val1)) = (HN32 (<= val0 val1))
(HOperate EQL (HN32 val0) (HN32 val1)) = (HN32 (== val0 val1))
(HOperate GTE (HN32 val0) (HN32 val1)) = (HN32 (>= val0 val1))
(HOperate GTN (HN32 val0) (HN32 val1)) = (HN32 (>  val0 val1))
(HOperate NEQ (HN32 val0) (HN32 val1)) = (HN32 (!= val0 val1))
(HOperate oper val0       val1)        = (HO32 oper val0 val1)

// High-order application
(HApply (HLam fbody) argm) = (fbody argm)
(HApply func         argm) = (HApp func argm)

// Converts a term to low-order
(Low term) = (Low.Go term 0)

  (Low.Go (HLev name numb) depth) =
    (Var name)

  (Low.Go (HVar name) depth) =
    (Var name)

  (Low.Go (HUse name numb) depth) =
    (Use name numb)

  (Low.Go (HHol hash) depth) =
    (Hol hash)

  (Low.Go HTyp depth) =
    Typ

  (Low.Go HU60 depth) =
    U60

  (Low.Go (HN32 numb) depth) =
    (N32 numb)

  (Low.Go (HO32 oper val0 val1) depth) =
    let val0 = (Low.Go val0 depth)
    let val1 = (Low.Go val1 depth)
    (O32 oper val0 val1)

  (Low.Go (HGol name) depth) =
    (Gol name)

  (Low.Go (HAll type body) depth) =
    let name = (Name.Make (String.cons (+ 97 depth) String.nil))
    let type = (Low.Go type depth)
    let body = (Low.Go (body (HVar name)) (+ depth 1))
    (All name type body)

  (Low.Go (HLam body) depth) =
    let name = (Name.Make (String.cons (+ 97 depth) String.nil))
    let body = (Low.Go (body (HVar name)) (+ depth 1))
    (Lam name body)

  (Low.Go (HApp func argm) depth) =
    let func = (Low.Go func depth)
    let argm = (Low.Go argm depth)
    (App func argm)

  (Low.Go (HCts ctid args) depth) =
    let args = (Low.Go.Many args depth)
    (Cts ctid args)

  (Low.Go (HEql val0 val1) depth) =
    let val0 = (Low.Go val0 depth)
    let val1 = (Low.Go val1 depth)
    (Eql val0 val1)

  (Low.Go (HRfl expr) depth) =
    let expr = (Low.Go expr depth)
    (Rfl expr)

  (Low.Go (HRwt name witn goal expr) depth) =
    let name = (Name.Make (String.cons (+ 97 depth) String.nil))
    let witn = (Low.Go witn depth)
    let goal = (Low.Go (goal (HVar name)) (+ depth 1))
    let expr = (Low.Go expr depth)
    (Rwt name witn goal expr)

  (Low.Go.Many (Cons x xs) depth) =
    let x  = (Low.Go x depth)
    let xs = (Low.Go.Many xs depth)
    (Cons x xs)
  (Low.Go.Many Nil depth) =
    Nil

// Normalizes a term
(Normal file term) = (Low (High file term Nil))



// Type-Checking
// -------------

// type Equation {
//   Equation(a: HTerm, b: HTerm, ctx: Ctx)
// }

// type Argument {
//   Argument(name: Name, type: HTerm)
// }

// Result : Type -> Type
// Result A
//   = Checked (List Equation) (List Argument) A
//   | Errored String

(Chain (Errored str)         b_result) = (Errored str)
(Chain (Checked eqs ars val) b_result) = (b_result eqs ars val)

// (Infer.Go File Term Ctx) : (Result HTerm)
(Infer file term ctx) = (Infer.Unify file 0 (Infer.Go file term ctx Nil Nil))

  (Infer.Unify file capt (Errored err)        ) = (Errored err)
  (Infer.Unify file capt (Checked eqs ars typ)) = (Infer.Finish (Unify file capt eqs ars Empty) typ)

  (Infer.Finish (Errored err)           typ) = (Errored err)
  (Infer.Finish (Checked eqs ars subst) typ) = (Checked eqs ars (Pair subst (Holes.Subst subst typ)))

  // (Infer.Go File Term Ctx (List Equation)) : (Result HTerm)

  // TODO: linearize file? probably not needed
  (Infer.Go file (Var name) ctx eqs ars) = (Infer.Go.Find name ctx eqs ars)
    (Infer.Go.Find name Nil eqs ars) = (Errored (String.Flatten ["Unbound: " (Name.GetString name)]))
    (Infer.Go.Find name (Cons (Pair var typ) ctx) eqs ars) = (Infer.Go.Found (Name.Equal name var) name typ ctx eqs ars)
      (Infer.Go.Found 1 name typ ctx eqs ars) = (Checked eqs ars typ)
      (Infer.Go.Found 0 name typ ctx eqs ars) = (Infer.Go.Find name ctx eqs ars)

  (Infer.Go file (Hol hash) ctx eqs ars) =
    (Checked eqs ars HTyp)

  (Infer.Go file Typ ctx eqs ars) =
    (Checked eqs ars HTyp)

  (Infer.Go file U60 ctx eqs ars) =
    (Checked eqs ars HTyp)

  (Infer.Go file (N32 numb) ctx eqs ars) =
    (Checked eqs ars HU60)

  (Infer.Go file (O32 oper val0 val1) ctx eqs ars) =
    (Chain (Check.Go file val0 HU60 ctx eqs ars) λeqs λars λok
    (Chain (Check.Go file val1 HU60 ctx eqs ars) λeqs λars λok
    (Checked eqs ars HU60)))

  (Infer.Go file (Gol name) ctx eqs ars) =
    (Checked eqs ars (HGol name))

  (Infer.Go file (Ann eras xval xtyp) ctx eqs ars) =
    let htyp = (High file xtyp Nil)
    (Chain (Check.Go file xtyp HTyp ctx eqs ars) λeqs λars λok
    (Chain (Check.Go file xval htyp ctx eqs ars) λeqs λars λok
    (Checked eqs ars htyp)))

  (Infer.Go file (All name type body) ctx eqs ars) =
    (Chain (Check.Go file type HTyp ctx eqs ars) λeqs λars λok
    (Chain (Check.Go file body HTyp (Cons (Pair name (High file type Nil)) ctx) eqs ars) λeqs λars λok
    (Checked eqs ars HTyp)))

  (Infer.Go file (Let name expr body) ctx eqs ars) =
    (Chain (Infer.Go file expr ctx eqs ars) λeqs λars λexpr_t
    (Infer.Go file body (Cons (Pair name expr_t) ctx) eqs ars))

  (Infer.Go file (Lam name body) ctx eqs ars) =
    (Errored "Can't infer lambda.")

  (Infer.Go file (App func argm) ctx eqs ars) =
    (Chain (Infer.Go file func ctx eqs ars) λeqs λars λft (Infer.Go.App file ft argm ctx eqs ars))
      (Infer.Go.App file (HAll ftype fbody) argm ctx eqs ars) =
        (Chain (Check.Go file argm ftype ctx eqs ars) λeqs λars λok
        (Checked eqs ars (fbody (High file argm Nil))))
      (Infer.Go.App file other argm ctx eqs ars) =
        (Errored "Non-function application.")

  (Infer.Go file (Eql val0 val1) ctx eqs ars) =
    (Chain (Infer.Go file val0 ctx eqs ars) λeqs λars λval0_t
    (Chain (Infer.Go file val1 ctx eqs ars) λeqs λars λval1_t
    (Checked eqs ars HTyp)))

  (Infer.Go file (Rfl expr) ctx eqs ars) =
    let hexpr = (High file expr Nil)
    (Checked eqs ars (HEql hexpr hexpr))

  (Infer.Go file (Rwt name witn goal expr) ctx eqs args) =
    (Chain (Infer.Go file witn ctx eqs args) λeqs λars λwitn_typ
    (Infer.Go.Rwt file witn_typ name goal expr ctx eqs ars))

    (Infer.Go.Rwt file (HEql val0 val1) name goal expr ctx eqs ars) =
      let goal = λx (High file goal (CloneFor goal name x Nil))
      (Chain (Check.Go file expr (goal val1) ctx eqs ars) λeqs λars λok
      (Checked eqs ars (goal val0)))
    (Infer.Go.Rwt file a name goal expr ctx eqs ars) =
      (Errored "Invalid rewrite witness.")

  (Infer.Go file (Rwt name witn goal expr) ctx eqs args) =
    (Errored "Can't infer rewrite.")

  // Cts checker
  (Infer.Go file (Cts id args) ctx eqs ars) = (Infer.Go.Cts.FindFunc file id (Cts id args) ctx eqs ars)

    // 1. Find Cts's type on file
    (Infer.Go.Cts.FindFunc file ctid term ctx eqs ars) =
      (Pair.Get (File.GotFunc file ctid) λfile λfunc
      (Maybe.Case func (Errored (String.Concat "Type not found for: " (Term.Show file term))) λfunc // FIXME: File.GotFunc should store Maybes
      (Func.Get func λlty λrty λrul
      (Infer.Go.Cts.MakeList file ctid lty rty term ctx eqs ars))))

    // 2. Convert types and args to lists (FIXME: not necessary anymore, remove)
    (Infer.Go.Cts.MakeList file ctid (Cts t.id t.args) rt (Cts id args) ctx eqs ars) = (Infer.Go.Cts.CheckList file t.args args rt [] ctx eqs ars)
    (Infer.Go.Cts.MakeList file ctid lt                rt term          ctx eqs ars) = (Errored (String.Concat "Type not found for: " (Term.Show file term))) // FIXME: File.GotFunc should store Maybes

    // 3. Recursively checks the lists
    (Infer.Go.Cts.CheckList file Nil Nil rtyp sub ctx eqs ars) =
      (Checked eqs ars (Infer.Go.Cts.High file rtyp sub))
    (Infer.Go.Cts.CheckList file (Cons typ typs) (Cons val vals) rtyp sub ctx eqs ars) =
      (Arg.Get typ λtyp.name λtyp.expr
      let hig = (High file val Nil)
      let typ = (Infer.Go.Cts.High file typ.expr sub)
      let sub = (Cons (Pair typ.name hig) sub)
      (Chain (Check.Go file val typ ctx eqs ars) λeqs λars λres
      (Infer.Go.Cts.CheckList file typs vals rtyp sub ctx eqs ars)))
    (Infer.Go.Cts.CheckList file typs vals rtyp sub ctx eqs ars) =
      (Errored "Arity mismatch.")
      
    // Convert term to high-order, substituting arguments
    (Infer.Go.Cts.High file term vars) = (High file term (Infer.Go.Cts.High.Vars file term vars))
      (Infer.Go.Cts.High.Vars file term Nil) = Nil
      (Infer.Go.Cts.High.Vars file term (Cons (Pair name expr) vals)) =
        (CloneFor term name expr
        (Infer.Go.Cts.High.Vars file term vals))

// (Check File Term HTerm Ctx) : (Result Subst)
(Check file term type ctx) = (CheckUnify file 0 (Check.Go file term type ctx Nil Nil))

  // (CheckUnify File Capt (Result Unit)) : (Result (Map HTerm))
  (CheckUnify file capt (Errored err))         = (Errored err)
  (CheckUnify file capt (Checked eqs ext uni)) = (Unify file capt eqs ext Empty)

  // (Check.Go File Term HTerm Ctx (List Equation)) : (Result Unit)

  // TODO: store (name : typ) on match list?
  (Check.Go file (Use name numb) typ ctx eqs ext) =
    (Checked eqs (Cons (Pair name typ) ext) Unit)

  (Check.Go file (Hol hash) type ctx eqs ext) =
    (Checked eqs ext Unit)

  // FIXME: cache depth to avoid List.Length
  (Check.Go file (Lam name body) (HAll t_type t_body) ctx eqs ext) =
    (Chain (Check.Go file body (t_body (HLev name (List.Length ctx))) (Cons (Pair name t_type) ctx) eqs ext) λeqs λext λres
    (Checked eqs ext res))

  (Check.Go file (Let name expr body) type ctx eqs ext) =
    (Chain (Infer.Go file expr ctx eqs ext) λeqs λext λexpr_t
    (Check.Go file body type (Cons (Pair name expr_t) ctx) eqs ext))

  // FIXME: optimize by storing the recursion depth, avoiding List.Length
  (Check.Go file term type ctx eqs ext) =
    (Chain (Infer.Go file term ctx eqs ext) λeqs λext λterm_t
    (Checked (Cons (Equation type term_t (List.Length ctx) ctx) eqs) ext Unit))

// TODO: I don't want to commit to any complex unification algorithm, so this
// implementation will just substitute immediate (flex-rigid) terms, for now.
// In a future, we should revisit this, and decide what unification and
// resolution algorithms we want to have on the language.
// (Unify File Capt eqs:(List (Pair HTerm HTerm)) subs:(Map HTerm)) : (Result (Map HTerm))
(Unify file capt eqs ext subst) = (Unify.Go file capt eqs ext subst Nil)
  (Unify.Go file capt Nil ext subst Nil)  = (Checked Nil ext subst)
  (Unify.Go file capt Nil ext subst errs) = (Errored (String.Join (List.Map errs λx(x subst)) NewLine))
  (Unify.Go file capt (Cons (Equation a b dep ctx) eqs) ext subst errs) =
    (Trip.Get (Equal file capt a b dep subst ext) λsubst λext λeq
    (UnifyTest file capt eq a b ctx eqs ext subst errs))

  (UnifyTest file capt 0 a b ctx eqs ext subst errs) =
    let err = λsubst (String.Flatten [
      "Type mismatch." NewLine
      "- Expected: " (Term.Show file (Low (Holes.Subst subst a))) NewLine
      "- Detected: " (Term.Show file (Low (Holes.Subst subst b))) NewLine
      (Context.Show (List.Map ctx λp(Pair.MutSnd p λx(Low (Holes.Subst subst x)))) file) NewLine
    ])
    (Unify.Go file capt eqs ext subst (Cons err errs))
  (UnifyTest file capt 1 a b ctx eqs ext subst errs) =
    (Unify.Go file capt eqs ext subst errs)

// FIXME: this will loop if we subst `a_hash <- (HHol a_hash)`, since the Equal
// rewrite rule will be called repeatedly. I don't have the time to reason about
// this right now, so I'll leave this to a future.
// (Equal U60 HTerm HTerm U60 Subst (List Argument)) : (Trip Subst (List Argument) Bool)

(Equal file k (HLev a_name a_numb) (HLev b_name b_numb) depth subst ext) =
  (Trip subst ext (== a_numb b_numb))

(Equal file 0 (HVar a_name) (HVar b_name) depth subst ext) =
  (Trip subst ext (Name.Equal a_name b_name))

(Equal file 1 (HVar a_name) b depth subst ext) =
  (Capt file (HVar a_name) b subst ext)

(Equal file 1 a (HVar b_name) depth subst ext) =
  (Capt file a (HVar b_name) subst ext)

(Equal file k HTyp HTyp depth subst ext) =
  (Trip subst ext 1)

(Equal file k HU60 HU60 depth subst ext) =
  (Trip subst ext 1)

(Equal file k (HN32 a_numb) (HN32 b_numb) depth subst ext) =
  (Trip subst ext (== a_numb b_numb))

(Equal file k (HO32 a_oper a_val0 a_val1) (HO32 b_oper b_val0 b_val1) depth subst ext) =
  (Trip.Get (Equal file k a_val0 b_val0 depth subst ext) λsubst λext λval0_eq
  (Trip.Get (Equal file k a_val1 b_val1 depth subst ext) λsubst λext λval1_eq
  (Trip subst ext (& (== a_oper b_oper) (& val0_eq val1_eq)))))

(Equal file k (HGol a_name) (HGol b_name) depth subst ext) =
  (Trip subst ext 1)

(Equal file k (HAll a_type a_body) (HAll b_type b_body) depth subst ext) =
  (Trip.Get (Equal file k a_type b_type depth subst ext) λsubst λext λtype_eq
  (Trip.Get (Equal file k (a_body (HLev (Name.Make "?") depth)) (b_body (HLev (Name.Make "?") depth)) (+ depth 1) subst ext) λsubst λext λbody_eq
  (Trip subst ext (& type_eq body_eq))))

(Equal file k (HLam a_body) (HLam b_body) depth subst ext) =
  (Trip.Get (Equal file k (a_body (HLev (Name.Make "?") depth)) (b_body (HLev (Name.Make "?") depth)) (+ depth 1) subst ext) λsubst λext λbody_eq
  (Trip subst ext body_eq))

(Equal file k (HApp a_func a_argm) (HApp b_func b_argm) depth subst ext) =
  (Trip.Get (Equal file k a_func b_func depth subst ext) λsubst λext λfunc_eq
  (Trip.Get (Equal file k a_argm b_argm depth subst ext) λsubst λext λargm_eq
  (Trip subst ext (& func_eq argm_eq))))

(Equal file k (HCts a.ctid a.args) (HCts b.ctid b.args) depth subst ext) =
  (Equal.HCts file (Equal.Capts file k a.ctid b.ctid) (Name.Equal a.ctid b.ctid) (HCts a.ctid a.args) (HCts b.ctid b.args) depth subst ext)

  (Equal.HCts file 0 0 a                    b                    depth subst ext) = (Trip subst ext 0)
  (Equal.HCts file 1 0 a                    b                    depth subst ext) = (Capt file a b subst ext)
  (Equal.HCts file k 1 (HCts a.ctid a.args) (HCts b.ctid b.args) depth subst ext) = (Equal.Many file k a.args b.args depth subst ext)
    
(Equal file k (HEql a_val0 a_val1) (HEql b_val0 b_val1) depth subst ext) =
  (Trip.Get (Equal file k a_val0 b_val0 depth subst ext) λsubst λext λval0_eq
  (Trip.Get (Equal file k a_val1 b_val1 depth subst ext) λsubst λext λval1_eq
  (Trip subst ext (& val0_eq val1_eq))))

(Equal file k (HRwt a_name a_witn a_goal a_expr) (HRwt b_name b_witn b_goal b_expr) depth subst ext) =
  (Trip.Get (Equal file k a_witn b_witn depth subst ext) λsubst λext λwitn_eq
  (Trip.Get (Equal file k (a_goal (HLev "" depth)) (b_goal (HLev "" depth)) (+ depth 1) subst ext) λsubst λext λbody_eq
  (Trip.Get (Equal file k a_expr b_expr depth subst ext) λsubst λext λexpr_eq
  (Tri subst ext (& witn_eq (& body_eq expr_eq))))))

(Equal file k (HHol a_hash) (HHol b_hash) depth subst ext) =
  (Trip subst ext 1)

(Equal file k (HHol a_hash) b depth subst ext) = (Pair.Get (Got subst a_hash) λsubst λgot_a (Equal.Got.0 file k a_hash got_a b depth subst ext))
  (Equal.Got.0 file k a_hash None     b depth subst ext) = (Trip (Set subst a_hash b) ext 1)
  (Equal.Got.0 file k a_hash (Some a) b depth subst ext) = (Equal file k a b depth subst ext)

(Equal file k a (HHol b_hash) depth subst ext) = (Pair.Get (Got subst b_hash) λsubst λgot_b (Equal.Got.1 file k b_hash a got_b depth subst ext))
  (Equal.Got.1 file k b_hash a None     depth subst ext) = (Trip (Set subst b_hash a) ext 1)
  (Equal.Got.1 file k b_hash a (Some b) depth subst ext) = (Equal file k a b depth subst ext)

(Equal file k a b depth subst ext) =
  (Trip subst ext 0)

(Equal.Many file k Nil         Nil         depth subst ext) = (Trip subst ext 1)
(Equal.Many file k Nil         (Cons b bs) depth subst ext) = (Trip subst ext 0)
(Equal.Many file k (Cons a as) Nil         depth subst ext) = (Trip subst ext 0)
(Equal.Many file k (Cons a as) (Cons b bs) depth subst ext) =
  (Trip.Get (Equal      file k a  b  depth subst ext) λsubst λext λa.eq
  (Trip.Get (Equal.Many file k as bs depth subst ext) λsubst λext λas.eq
  (Trip subst ext (& a.eq as.eq))))

(Equal.Capts file k a.ctid b.ctid) =
  (U60.And k (& (File.IsCtr file a.ctid) (File.IsCtr file b.ctid)))

(Capt file a b subst ext) =
  //let a_s = (Term.Show (File.Make []) (Low a))
  //let b_s = (Term.Show (File.Make []) (Low b))
  //let var = (HVar (Name.Make (String.Flatten [a_s " == " b_s]))) // fixme: temporary hack for visualization, until equality is implemented
  let cap = (HEql b a)
  let ext = (Cons (Pair (Name.Make (String.Concat "." (U60.Show (List.Length ext)))) cap) ext)
  (Trip subst ext 1)

// (Holes.Subst Subst HTerm) : HTerm
(Holes.Subst subst (HVar name))                = (HVar name)
(Holes.Subst subst (HLev name numb))           = (HLev name numb)
(Holes.Subst subst (HUse name numb))           = (HUse name numb)
(Holes.Subst subst HTyp)                       = HTyp
(Holes.Subst subst HU60)                       = HU60
(Holes.Subst subst (HN32 numb))                = (HN32 numb)
(Holes.Subst subst (HO32 oper val0 val1))      = (HO32 oper (Holes.Subst subst val0) (Holes.Subst subst val1))
(Holes.Subst subst (HGol name))                = (HGol name)
(Holes.Subst subst (HAnn eras xval xtyp))      = (HAnn eras (Holes.Subst subst xval) (Holes.Subst subst xtyp))
(Holes.Subst subst (HLet expr body))           = (HLet (Holes.Subst subst expr) λx(Holes.Subst subst (body x)))
(Holes.Subst subst (HAll type body))           = (HAll (Holes.Subst subst type) λx(Holes.Subst subst (body x)))
(Holes.Subst subst (HLam body))                = (HLam λx(Holes.Subst subst (body x)))
(Holes.Subst subst (HApp func argm))           = (HApp (Holes.Subst subst func) (Holes.Subst subst argm))
(Holes.Subst subst (HCts ctid args))           = (HCts ctid args)
(Holes.Subst subst (HEql val0 val1))           = (HEql (Holes.Subst subst val0) (Holes.Subst subst val1))
(Holes.Subst subst (HRfl expr))                = (HRfl (Holes.Subst subst expr))
(Holes.Subst subst (HRwt name witn goal expr)) = (HRwt name (Holes.Subst subst witn) λx(Holes.Subst subst (goal x)) (Holes.Subst subst expr))
(Holes.Subst subst (HHol hash))                = (Pair.Get (Got subst hash) λsubst λgot (HolesGot.Subst subst hash got))
  (HolesGot.Subst subst hash None)             = (HHol hash)
  (HolesGot.Subst subst hash (Some x))         = (Holes.Subst subst x)

// (Holes.Count Term) : U60
(Holes.Count (Var name))                = 0
(Holes.Count (Lev name numb))           = 0
(Holes.Count (Use name numb))           = 0
(Holes.Count Typ)                       = 0
(Holes.Count U60)                       = 0
(Holes.Count (N32 numb))                = 0
(Holes.Count (O32 oper val0 val1))      = (+ (Holes.Count val0) (Holes.Count val1))
(Holes.Count (Gol name))                = 0
(Holes.Count (Ann eras xval xtyp))      = (+ (Holes.Count xval) (Holes.Count xtyp))
(Holes.Count (Let name expr body))      = (+ (Holes.Count expr) (Holes.Count body))
(Holes.Count (All name type body))      = (+ (Holes.Count type) (Holes.Count body))
(Holes.Count (Lam name body))           = (Holes.Count body)
(Holes.Count (App func argm))           = (+ (Holes.Count func) (Holes.Count argm))
(Holes.Count (Cts ctid args))           = (Holes.Count.Many args)
(Holes.Count (Eql val0 val1))           = (+ (Holes.Count val0) (Holes.Count val1))
(Holes.Count (Rfl expr))                = (Holes.Count expr)
(Holes.Count (Rwt name witn goal expr)) = (+ (Holes.Count witn) (+ (Holes.Count goal) (Holes.Count expr)))
(Holes.Count (Hol hash))                = 1

(Holes.Count.Many Nil)         = 0
(Holes.Count.Many (Cons x xs)) = (+ (Holes.Count x) (Holes.Count.Many xs))

// (Verify.File File) : String
(Verify.File file) = (Verify.End (Verify.Funcs file (Map.Values (File.GetFuncs file))))
  (Verify.End String.nil) = "All terms check."
  (Verify.End errors) = errors

// (Verify.Funcs File (List Func)) : String
(Verify.Funcs file Nil) = String.nil
(Verify.Funcs file (Cons func funcs)) =
  let head = (Verify.Func file func)
  let tail = (Verify.Funcs file funcs)
  (String.Concat head tail)

// (Verify.Func File Func) : String
(Verify.Func file (Func lty rty rules)) =
  let name = (Func.GetName (Func lty rty rules) file)
  let err  = (Verify.Rules file lty rty rules)
  (Verify.Print name err)

  (Verify.Print name err) =
    (If (String.IsEmpty err) ""
      let title = (String.Flatten ["Error on '" name "':"])
      let tline = (String.Map title λx('-'))
      (String.Flatten [
        NewLine
        title NewLine
        tline NewLine
        NewLine
        err
        NewLine
      ]))

// (Verify.Rules File Term Term Rules) : String
(Verify.Rules file lty rty End) = ""
(Verify.Rules file lty rty (Rule lhs rhs rules)) =
  let hols = (Holes.Count rhs)
  let head = (Verify.Rule  file lty rty lhs rhs)
  let tail = (Verify.Rules file lty rty rules)
  (Verify.Rules.ConcatErrors hols head tail)

  (Verify.Rules.ConcatErrors hols (Errored err)          str) = (String.Concat err str)
  (Verify.Rules.ConcatErrors hols (Checked eqs ext subs) str) =
    ((U60.If (U60.Not (== (Len subs) hols))
      λstr (String.Concat "Unfilled holes." str)
      λstr (str))
      str)

// (Verify.Rule File Term Term Term Term) : (Result (Map HTerm))
(Verify.Rule file (Cts typ.ctid typ.args) r.typ (Cts val.ctid val.args) r.val) =
  (Verify.Rule.List file typ.args r.typ val.args r.val)
(Verify.Rule file a.typ r.typ a.val r.val) =
  let rule_name = (Name.GetString (Ctr.GetId a.val))
  (Errored (String.Flatten [
    "Mistyped rule: " rule_name NewLine NewLine 
  ]))

// (Verify.Rule.List File Term Term Term Term) : (Result (Map HTerm))
(Verify.Rule.List file typs r.typ vals r.val) =
  (CheckUnify file 0 (Verify.Rule.List.Go file typs r.typ vals r.val Nil Nil Nil))

  (Verify.Rule.List.Go file Nil r.typ Nil r.val pre eqs ext) =
    let sub = (Verify.Rule.List.Sub r.typ pre)
    let hty = (High file r.typ sub)
    (Check.Go file r.val hty ext eqs ext)
  (Verify.Rule.List.Go file (Cons typ typs) r.typ (Cons val vals) r.val pre eqs ext) =
    (Arg.Get typ λtyp.name λtyp.expr
    let hva = (High file val Nil)
    let hty = (High file typ.expr (Verify.Rule.List.Sub typ.expr pre))
    let pre = (Cons (Pair typ.name hva) pre)
    (Chain (CheckUnify file 1 (Check.Go file val hty Nil eqs ext)) λeqs λext λok
    (Verify.Rule.List.Go file typs r.typ vals r.val pre eqs ext)))
  (Verify.Rule.List.Sub bod Nil) = Nil
  (Verify.Rule.List.Sub bod (Cons (Pair name type) vals)) =
    (CloneFor bod name type (Verify.Rule.List.Sub bod vals))



// Compiler
// ========


// (Compile.to_hvm term:Term file:File) : String
(Compile.HVM file term) = ((Compile.HVM.Go file term) "")
  (Compile.HVM.Go file (Var name)) =
    λx((String.Show.Go (Name.GetString name))
      x)
  (Compile.HVM.Go file (Use name uses)) =
    λx((String.Show.Go (Name.GetString name))
      x)
  (Compile.HVM.Go file (Hol hash)) =
    λx((String.Show.Go "_")
      ((String.Show.Go (U60.Show hash))
      x))
  (Compile.HVM.Go file (Let name expr body)) =
    λx((String.Show.Go "let ")
      ((String.Show.Go (Name.GetString name))
      ((String.Show.Go " = ")
      ((Compile.HVM.Go file expr)
      ((String.Show.Go "; ")
      ((Compile.HVM.Go file body)
      x))))))
  (Compile.HVM.Go file (Ann eras xval xtyp)) =
    λx((Compile.HVM.Go file xval)
      x)
  (Compile.HVM.Go file Typ) =
    λx((String.Show.Go "Type")
      x)
  (Compile.HVM.Go file U60) =
    λx((String.Show.Go "U60")
      x)
  (Compile.HVM.Go file (N32 numb)) =
    λx((String.Show.Go (U60.Show numb))
      x)
  (Compile.HVM.Go file (O32 oper val0 val1)) =
    λx((String.Show.Go "(")
      ((Oper.Show.Go oper)
      ((String.Show.Go " ")
      ((Compile.HVM.Go file val0)
      ((String.Show.Go " ")
      ((Compile.HVM.Go file val1)
      ((String.Show.Go ")")
      x)))))))
  (Compile.HVM.Go file (Gol name)) =
    λx((String.Show.Go "?")
      ((String.Show.Go name)
      x))
  (Compile.HVM.Go file (All name type body)) =
    λx((String.Show.Go "0")
      x)
  (Compile.HVM.Go file (Lam name body)) =
    λx((String.Show.Go "λ")
      ((String.Show.Go (Name.GetString name))
      ((String.Show.Go " ")
      ((Compile.HVM.Go file body)
      x))))
  (Compile.HVM.Go file (App func argm)) =
    λx((String.Show.Go "(")
      ((Compile.HVM.Go file func)
      ((String.Show.Go " ")
      ((Compile.HVM.Go file argm)
      ((String.Show.Go ")")
      x)))))
  (Compile.HVM.Go file (Cts ctid args)) =
    (Maybe.Case (Compile.StringLiteral.Go (Cts ctid args))
      // case none
      let typs = (Maybe.Case (File.GetFunc file ctid) [] λf(Ctr.GetArgs (Func.GetInputType f)))
      λx((String.Show.Go "(")
        ((String.Show.Go (Name.GetString ctid))
        ((Compile.HVM.Go.Cts.Args file typs args)
        ((String.Show.Go ")")
        x))))
      // case some
      λres λx (res x))
  (Compile.HVM.Go file (Eql val0 val1)) =
    λx((String.Show.Go "0")
      x)
  (Compile.HVM.Go file (Rfl expr)) =
    λx((String.Show.Go "0")
      x)
  (Compile.HVM.Go file (Rwt name witn goal expr)) =
    λx((Compile.HVM.Go file expr)
      x)
  (Compile.HVM.Go.Cts.Args file typs Nil) =
    λx(x)
  (Compile.HVM.Go.Cts.Args file (Cons typ typs) (Cons arg args)) =
    λx((If (Ann.IsErased typ) λx(x) λx((String.Show.Go " ") ((Compile.HVM.Go file arg) x)))
      ((Compile.HVM.Go.Cts.Args file typs args)
      x))

// (Compile.StringLiteral Term) : (Maybe (∀Term -> Term))
(Compile.StringLiteral term) = (Maybe.Case (Compile.StringLiteral.Go term) None λx(x String.nil))
  (Compile.StringLiteral.Go term) = (Maybe.Case (Compile.StringLiteral.Go.Ini term) None λs(Some λx(String.cons '"' (s (String.cons '"' x)))))
    (Compile.StringLiteral.Go.Ini (Cts ctid args)) = (Compile.StringLiteral.Go.Cts (Name.GetHash ctid) args)
    (Compile.StringLiteral.Go.Ini other) = None
      (Compile.StringLiteral.Go.Cts 2296656871382740  args) = (Some λx(x))
      (Compile.StringLiteral.Go.Cts 71196363012543182 args) = (Compile.StringLiteral.Go.Cts.String.cons args)
        (Compile.StringLiteral.Go.Cts.String.cons (Cons chr (Cons chrs Nil))) =
          let val = (N32.GetValue chr)
          (U60.If (== val '"')
            // then
            None
            // else
            (Maybe.Bind (Compile.StringLiteral.Go.Ini chrs) λstr
            (Some λx(String.cons val (str x)))))
        (Compile.StringLiteral.Go.Cts.String.cons (Cons chr Nil)) = None
        (Compile.StringLiteral.Go.Cts.String.cons Nil) = None
      (Compile.StringLiteral.Go.Cts ctid args) = None

(Oper.Show.Go ADD) = (String.Show.Go "+")
(Oper.Show.Go SUB) = (String.Show.Go "-")
(Oper.Show.Go MUL) = (String.Show.Go "*")
(Oper.Show.Go DIV) = (String.Show.Go "/")
(Oper.Show.Go MOD) = (String.Show.Go "%")
(Oper.Show.Go AND) = (String.Show.Go "&")
(Oper.Show.Go OR)  = (String.Show.Go "|")
(Oper.Show.Go XOR) = (String.Show.Go "^")
(Oper.Show.Go SHL) = (String.Show.Go "<<")
(Oper.Show.Go SHR) = (String.Show.Go ">>")
(Oper.Show.Go LTN) = (String.Show.Go "<")
(Oper.Show.Go LTE) = (String.Show.Go "<=")
(Oper.Show.Go EQL) = (String.Show.Go "==")
(Oper.Show.Go GTE) = (String.Show.Go ">=")
(Oper.Show.Go GTN) = (String.Show.Go ">")
(Oper.Show.Go NEQ) = (String.Show.Go "!=")



// #############################################################################
// # Tests                                                                     #
// #############################################################################



(Test.0) = `
  // Booleans
  Bool : Type
    True  : Bool
    False : Bool

  // Natural numbers
  Nat : Type
    Zero         : Nat
    (Succ n:Nat) : Nat

  // Lists
  (List t:Type) : Type
    (Nil t:Type)                  : (List t)
    (Cons t:Type x:t xs:(List t)) : (List t)

  // Equality (non-native)
  (Equal t:Type a:t b:t) : Type
    (Refl t:Type a:t) : (Equal t a a)

  // Negates a boolean
  (Bool.Not b:Bool) : Bool
    (Bool.Not True)  = False
    (Bool.Not False) = True

  // Doubles a number
  (Nat.Double n:Nat) : Nat
    (Nat.Double Zero)     = Zero
    (Nat.Double (Succ n)) = (Succ (Succ (Nat.Double n)))

  // Halves a number
  (Nat.Half n:Nat) : Nat
    (Nat.Half Zero)            = Zero
    (Nat.Half (Succ Zero))     = Zero
    (Nat.Half (Succ (Succ x))) = (Succ (Nat.Half x))

  // Computes 2^n
  (Nat.Pow2 n:Nat) : Nat
    (Nat.Pow2 Zero)     = (Succ Zero)
    (Nat.Pow2 (Succ n)) = (Nat.Double (Nat.Pow2 n)) 

  // Destroys a Nat into 0
  (Nat.Destroy n:Nat) : Nat
    (Nat.Destroy Zero)     = Zero
    (Nat.Destroy (Succ n)) = (Nat.Destroy n)

  // Returns the first element of a list
  (List.Head t:Type x:(List t)) : t
    (List.Head t (Cons t x xs)) = x

  // Symmetry of equality
  (Sym t:Type a:t b:t e:{a == b}) : {b == a}
    (Sym t a b e) =
      rewrite x with e in {b == x}
      refl b

  // Transitivity of equality
  (Trans t:Type a:t b:t c:t e0:{a == b} e1:{b == c}) : {a == c}
  (Trans t a b c e0 e1) =
    rewrite x with e0 in {x == c}
    e1

  // Congruence of equality
  (Cong t:Type u:Type a:t b:t f:∀(x:t)u e:{a == b}) : {(f a) == (f b)}
    (Cong t u a b f e) =
      rewrite x with e in {(f x) == (f b)}
      refl (f b)

  // Casting values to another equal type
  (Cast a:Type b:Type e:{a == b} x:a) : b
    (Cast a b e x) =
      rewrite x with (Sym Type a b e) in x
      x

  // Symmetry of equality on Equal
  (Equal.Sym t:Type a:t b:t e:(Equal t a b)) : (Equal t b a)
    (Equal.Sym t a b (Refl u x)) =
      def xx = (Cast u t .5 x)
      let e0 = (Sym t xx a .6)
      let e1 = (Trans t a xx b e0 .7)
      rewrite x with e1 in (Equal t b x)
      (Refl t b)

  // Double Negation Theorem
  (Bool.DNT b:Bool) : {(Bool.Not (Bool.Not b)) == b}
    (Bool.DNT True)  = refl True
    (Bool.DNT False) = refl False

  // Double Negation Theorem on Equal
  (Equal.Bool.DNT b:Bool) : (Equal Bool (Bool.Not (Bool.Not b)) b)
    (Equal.Bool.DNT True)  = (Refl Bool True)
    (Equal.Bool.DNT False) = (Refl Bool False)

  // Black Friday Theorem
  (Nat.BFT n:Nat) : {(Nat.Half (Nat.Double n)) == n}
    (Nat.BFT Zero)            = refl Zero
    (Nat.BFT (Succ Zero))     = refl (Succ Zero)
    (Nat.BFT (Succ (Succ n))) =
      let e0 = (Nat.BFT n)
      let e1 = (Cong _0 _1 _2 _3 λx(Succ x) e0)
      let e2 = (Cong _4 _5 _6 _7 λx(Succ x) e1)
      e2

  Foo : Nat
    Foo = (Nat.Destroy (Nat.Pow2
      (Succ (Succ
      (Succ (Succ (Succ (Succ (Succ (Succ (Succ
      (Succ (Succ (Succ (Succ (Succ (Succ (Succ
      Zero))))))))))))))))))

  Main : {Foo == Zero}
    Main = refl Zero
`

(Kind2.Check code) = (Kind2.Check.Go (File.Read code))
  (Kind2.Check.Go (Er err))  = err
  (Kind2.Check.Go (Ok file)) = (Verify.File file)

(Kind2.Run code) = (Kind2.Run.Go (File.Read code) "Main")
  (Kind2.Run.Go (Er err)  expr) = err
  (Kind2.Run.Go (Ok file) expr) = (Term.Show file (Normal file (Term.Read file expr)))

(Kind2.Compile code) = (Kind2.Compile.Go.0 (File.Read code))

  (Kind2.Compile.Go.0 (Er err))  = err
  (Kind2.Compile.Go.0 (Ok file)) = ((Kind2.Compile.Go.1 file (Map.Values (File.GetFuncs file))) "")

  (Kind2.Compile.Go.1 file Nil) = λx x
  (Kind2.Compile.Go.1 file (Cons (Func lty rty rules) xs)) = λx
    ((Kind2.Compile.Go.2 file rules)
    ((Kind2.Compile.Go.1 file xs) x))

  (Kind2.Compile.Go.2 file End) = λx x
  (Kind2.Compile.Go.2 file (Rule lhs rhs rs)) = λx
    ((Compile.HVM.Go file lhs)
    ((String.Show.Go " = ")
    ((Compile.HVM.Go file rhs) 
    ((String.Show.Go NewLine)
    ((Kind2.Compile.Go.2 file rs)
    x)))))

(Main n) = (Kind2.Check Test.0)

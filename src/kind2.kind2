// Kind2 implemented in Kind2
// ==========================

// Test. Running './bootstrap.hs' should produce a correct `main.hvm` file
Main : (List U60)
Main =
  let a = (List.cons U60 1 (List.cons U60 2 (List.nil U60)))
  let b = (List.cons U60 3 (List.cons U60 4 (List.nil U60)))
  (List.concat U60 a b)

// U60
// ===

(U60.if -a:Type cond:U60 if_t:a if_f:a): a
  (U60.if a 0 t f) = f
  (U60.if a 1 t f) = t

(U60.and a:U60 b:U60): U60
  (U60.and 0 b) = 0
  (U60.and 1 b) = b

(U60.not a:U60): U60
  (U60.not 0) = 1
  (U60.not 1) = 0

(U60.read str:String) : U60
  (U60.read str) = (U60.read.go str 0)

(U60.read.go str:String r:U60) : U60
  (U60.read.go String.nil         r) = r
  (U60.read.go (String.cons x xs) r) = (U60.if U60 (& (<= '0' x) (<= x '9')) (U60.read.go xs (+ (* r 10) (- x '0'))) 0) 

(U60.show n:U60) : String
  (U60.show n) = (U60.show_build n String.nil)

(U60.show_build n:U60 str:String) : String
  (U60.show_build n str) = 
    let next = (String.cons (+ 48 (% n 10)) str)
    let cond = (U60.if ∀(x:String)String (< n 10) λx(x) λx(U60.show_build (/ n 10) x))
    (cond next)

// Unit
// ====

Unit: Type
  Unit.new : Unit

// Bool
// ====

Bool: Type
  Bool.true  : Bool
  Bool.false : Bool

(Bool.if -a:Type Bool if_t:a if_f:a): a
  (Bool.if a Bool.false t f) = f
  (Bool.if a Bool.true  t f) = t

// Pair
// ====

(Pair a:Type b:Type): Type
  (Pair.new -a:Type -b:Type fst:a snd:b): (Pair a b)

(Pair.get -a:Type -b:Type c:Type p:(Pair a b) f:∀(x:a)∀(y:b)c): c
  (Pair.get a b c (Pair.new a b x y) f) = (f x y)

(Pair.fst -a:Type -b:Type p:(Pair a b)): a
  (Pair.fst a b (Pair.new a b x y)) = x

(Pair.snd -a:Type -b:Type p:(Pair a b)): b
  (Pair.snd a b (Pair.new a b x y)) = y

(Pair.fst.mut -a:Type -b:Type p:(Pair a b) f:∀(x:a)a): (Pair a b)
  (Pair.fst.mut a b (Pair.new a b x y) f) = (Pair.new a b (f x) y)

(Pair.snd.mut -a:Type -b:Type p:(Pair a b) f:∀(x:b)b): (Pair a b)
  (Pair.snd.mut a b (Pair.new a b x y) f) = (Pair.new a b x (f y))


// Triple
// ======

(Triple a:Type b:Type c:Type): Type
  (Triple.new a:Type b:Type c:Type fst:a snd:b trd:c): (Triple a b c)

(Triple.get -a:Type -b:Type -c:Type -d:Type t:(Triple a b c) f:∀(x:a)∀(y:b)∀(z:c)d): d
  (Triple.get a b c d (Triple.new a b c x y z) f) = (f x y z)

// Maybe
// =====

(Maybe a:Type): Type
  (Maybe.none -a:Type)     : (Maybe a)
  (Maybe.some -a:Type x:a) : (Maybe a)

(Maybe.case -a:Type -r:Type m:(Maybe a) none:r some:∀(x:a)r): r
  (Maybe.case a r (Maybe.some a x) case_none case_some) = (case_some x)
  (Maybe.case a r (Maybe.none a)   case_none case_some) = case_none

// Result 
// ======

(Result t:Type e:Type) : Type
  (Result.ok -t:Type -e:Type value:t) : (Result t e)
  (Result.err -t:Type -e:Type err:e) : (Result t e)

// List
// ====

(List a:Type): Type
  (List.nil -a:Type)                       : (List a)
  (List.cons -a:Type head:a tail:(List a)) : (List a)

(List.map -a:Type -b:Type l:(List a) f:∀(x:a)b): (List b)
  (List.map a b (List.nil a) f)            = (List.nil b)
  (List.map a b (List.cons a head tail) f) = (List.cons b (f head) (List.map a b tail f))

(List.reverse -a:Type l:(List a)): (List a)
  (List.reverse a l) = (List.reverse.go a l (List.nil a))

(List.reverse.go -a:Type l:(List a) r:(List a)): (List a)
  (List.reverse.go a (List.nil a)            r) = r
  (List.reverse.go a (List.cons a head tail) r) = (List.reverse.go a tail (List.cons a head r))

(List.length -a:Type l:(List a)): U60
  (List.length a (List.nil a))            = 0
  (List.length a (List.cons a head tail)) = (+ 1 (List.length a tail))

(List.is_empty -a:Type l:(List a)): U60
  (List.is_empty a (List.nil a))            = 1
  (List.is_empty a (List.cons a head tail)) = 0

(List.concat -a:Type xs:(List a) ys:(List a)): (List a)
  (List.concat a (List.nil a)       ys) = ys
  (List.concat a (List.cons a x xs) ys) = (List.cons a x (List.concat a xs ys))

(List.fold -a:Type -r:Type xs:(List a) nil:r cons:∀(x:a)∀(xs:r)r): r
  (List.fold a r (List.nil a)       nil cons) = nil
  (List.fold a r (List.cons a x xs) nil cons) = (cons x (List.fold a r xs nil cons))

(List.to_map -a:Type list:(List (Pair U60 a))) : (Map a)
  (List.to_map a list) = (List.to_map.go a list (Map.empty a))

(List.to_map.go -a:Type list:(List (Pair U60 a)) map:(Map a)) : (Map a)
  (List.to_map.go a (List.nil (Pair U60 a))                              map) = map
  (List.to_map.go a (List.cons (Pair U60 a) (Pair.new U60 a key val) xs) map) = (List.to_map.go a xs (Map.set a map key val))

// Name
// ====

Name : Type
  (Name.new str:String hash:U60) : Name

(Name.make str:String) : Name
  (Name.make str) = (Name.new str (String.hash str))

(Name.get_hash name:Name) : U60
  (Name.get_hash (Name.new str hash)) = hash

(Name.get_string name:Name) : String
  (Name.get_string (Name.new str hash)) = str
  (Name.get_string (Name.new str hash)) = (String.concat "TODO: Name.get_string" str)

(Name.equal a_name:Name b_name:Name) : U60
  (Name.equal (Name.new a_str a_hash) (Name.new b_str b_hash)) = (== a_hash b_hash)

// String
// ======

Char : Type
  Char = U60

String : Type
  (String.cons head:Char tail:String) : String
  (String.nil): String

// Returns true if a string is empty
(String.is_empty s:String): Bool
  (String.is_empty String.nil)         = Bool.true
  (String.is_empty (String.cons x xs)) = Bool.false

// Concatenates two strings
(String.concat a:String b:String) : String
  (String.concat String.nil         ys) = ys
  (String.concat (String.cons x xs) ys) = (String.cons x (String.concat xs ys))

// Concatenates a list of strings
(String.flatten a:(List String)) : String
  (String.flatten (List.nil a))            = String.nil
  (String.flatten (List.cons String x xs)) = (String.concat x (String.flatten xs))

// Returns true if two strings are equal
(String.equal xs:String ys:String) : U60
  (String.equal String.nil         String.nil)         = 1
  (String.equal (String.cons x xs) (String.cons y ys)) = (& (== x y) (String.equal xs ys))
  (String.equal xs                 ys)                 = 0

(String.hash xs:String) : U60
  (String.hash str) = (String.hash.go str 0)

(String.hash.go xs:String hash:U60) : U60
  (String.hash.go String.nil         hash) = hash
  (String.hash.go (String.cons x xs) hash) = (String.hash.go xs (+ (- (<< hash 5) hash) x))

(String.map xs:String f:∀(x:Char)Char) : String
  (String.map String.nil         f) = String.nil
  (String.map (String.cons x xs) f) = (String.cons (f x) (String.map xs f))

(String.join xs:(List String) sep:String) : String
  (String.join (List.nil String)                       sep) = String.nil
  (String.join (List.cons String x (List.nil String))  sep) = x
  (String.join (List.cons String x xs)                 sep) = (String.flatten (List.cons String x (List.cons String (String.join xs sep) (List.nil String))))

(String.take n:U60 xs:String) : String
  (String.take 0 xs) = String.nil
  (String.take n (String.cons x xs)) = (String.cons x (String.take (- n 1) xs))

(String.length xs:String) : U60
  (String.length String.nil)         = 0
  (String.length (String.cons x xs)) = (+ 1 (String.length xs))

(String.find text:String target:String) : (Maybe U60)
  (String.find text target) = (String.find.go text target 0)

(String.find.go text:String target:String n:U60) : (Maybe U60)
  (String.find.go String.nil target n) = (Maybe.none U60)
  (String.find.go (String.cons x xs) target n) = (String.find.go_aux (String.equal (String.take (String.length target) (String.cons x xs)) target) (String.cons x xs) target n)

(String.find.go_aux found:U60 text:String target:String n:U60) : (Maybe U60)
  (String.find.go_aux 1 text target n) = (Maybe.some U60 n)
  (String.find.go_aux 0 (String.cons x xs) target n) = (String.find.go xs target (+ n 1))

// Map
// ===

(Map a:Type) : Type
  (Map.empty -a:Type)                         : (Map a)
  (Map.entry -a:Type value:a)                 : (Map a)
  (Map.nodes -a:Type lft:(Map a) rgt:(Map a)) : (Map a)

(Map.length -a:Type tree:(Map a)) : U60
  (Map.length a (Map.empty a        )) = 0
  (Map.length a (Map.entry a     val)) = 1
  (Map.length a (Map.nodes a lft rgt)) = (+ (Map.length a lft) (Map.length a rgt))

(Map.get -a:Type tree:(Map a) key:U60) : (Pair (Map a) (Maybe a))
(Map.get a tree key) = (Map.get.go a 32 tree key (λx x))

(Map.get.go -a:Type n:U60 tree:(Map a) key:U60 self:∀(x:(Map a))(Map a)) : (Pair (Map a) (Maybe a))
  (Map.get.go a n (Map.empty a) key self) =
    (Pair.new (Map a) (Maybe a) (self (Map.empty a)) (Maybe.none a))
  (Map.get.go a n (Map.entry a val) key self) =
    (Pair.new (Map a) (Maybe a) (self (Map.entry a val)) (Maybe.some a val))
  (Map.get.go a n (Map.nodes a lft rgt) key self) =
    (Map.get.go.nodes a (& (>> key (- n 1)) 1) (- n 1) key lft rgt self)

(Map.get.go.nodes -a:Type i:U60 n:U60 key:U60 lft:(Map a) rgt:(Map a) self:∀(x:(Map a))(Map a)) : (Pair (Map a) (Maybe a))
  (Map.get.go.nodes a 0 n key lft rgt self) =
    (Map.get.go a n lft key λx(self (Map.nodes a x rgt)))
  (Map.get.go.nodes a 1 n key lft rgt self) =
    (Map.get.go a n rgt key λx(self (Map.nodes a lft x)))

(Map.delete -a:Type tree:(Map a) key:U60) : (Map a)
(Map.delete a tree key) = (Map.delete.go a 32 tree key)

(Map.delete.go -a:Type n:U60 tree:(Map a) key:U60) : (Map a)
  (Map.delete.go a n (Map.nodes a lft rgt) key) =
    (Map.delete.go.nodes a (& (>> key (- n 1)) 1) (- n 1) lft rgt key)
  (Map.delete.go a n tree key) = (Map.empty a)

(Map.delete.go.nodes -a:Type i:U60 n:U60 lft:(Map a) rgt:(Map a) key:U60) : (Map a)
  (Map.delete.go.nodes a 0 n lft rgt key) =
    (Map.nodes a (Map.delete.go a n lft key) rgt)
  (Map.delete.go.nodes a 1 n lft rgt key) =
    (Map.nodes a lft (Map.delete.go a n rgt key))

(Map.set -a:Type tree:(Map a) key:U60 val:a) : (Map a)
(Map.set a tree key val) = (Map.set.go a 32 tree key val)

(Map.set.go -a:Type n:U60 tree:(Map a) key:U60 val:a) : (Map a)
  (Map.set.go a 0 tree          key val) = (Map.entry a val)
  (Map.set.go a n (Map.empty a) key val) =
    (Map.set.go.empty a (& (>> key (- n 1)) 1) (- n 1) key val)
  (Map.set.go a n (Map.nodes a lft rgt) key val) =
    (Map.empty a)

(Map.set.go.empty -a:Type i:U60 n:U60 key:U60 val:a) : (Map a)
  (Map.set.go.empty a 0 n key val) =
    (Map.nodes a (Map.set.go a n (Map.empty a) key val) (Map.empty a))
  (Map.set.go.empty a 1 n key val) =
    (Map.nodes a (Map.empty a) (Map.set.go a n (Map.empty a) key val))

(Map.set.go.nodes -a:Type i:U60 n:U60 key:U60 lft:(Map a) rgt:(Map a) val:a) : (Map a)
  (Map.set.go.nodes a 0 n key lft rgt val) =
    (Map.nodes a (Map.set.go a n lft key val) rgt)
  (Map.set.go.nodes a 1 n key lft rgt val) =
    (Map.nodes a lft (Map.set.go a n rgt key val))

(Map.mut -a:Type tree:(Map a) key:U60 f:∀(v:a)a) : (Map a)
(Map.mut a tree key f) = (Map.mut.go a 32 tree key f)

(Map.mut.go -a:Type n:U60 tree:(Map a) key:U60 f:∀(v:a)a) : (Map a)
  (Map.mut.go a 0 (Map.entry a x) key f) = (Map.entry a (f x))
  (Map.mut.go a 0 tree            key f) = tree
  (Map.mut.go a n (Map.empty a)   key f) =
    (Map.mut.go.empty a (& (>> key (- n 1)) 1) (- n 1) key f)
  (Map.mut.go a n (Map.nodes a lft rgt) key f) =
    (Map.mut.go.nodes a (& (>> key (- n 1)) 1) (- n 1) key lft rgt f)

(Map.mut.go.empty -a:Type i:U60 n:U60 key:U60 f:∀(v:a)a) : (Map a)
  (Map.mut.go.empty a 0 n key f) =
    (Map.nodes a (Map.mut.go a n (Map.empty a) key f) (Map.empty a))
  (Map.mut.go.empty a 1 n key f) =
    (Map.nodes a (Map.empty a) (Map.mut.go a n (Map.empty a) key f))

(Map.mut.go.nodes -a:Type i:U60 n:U60 key:U60 lft:(Map a) rgt:(Map a) f:∀(v:a)a) : (Map a)
  (Map.mut.go.nodes a 0 n key lft rgt f) =
    (Map.nodes a (Map.mut.go a n lft key f) rgt)
  (Map.mut.go.nodes a 1 n key lft rgt f) =
    (Map.nodes a lft (Map.mut.go a n rgt key f))

(Map.to_list -a:Type val:(Map a)) : (List (Pair U60 a))
  (Map.to_list a val) = ((Map.to_list.go a val 0) (List.nil (Pair U60 a)))

(Map.to_list.go -a:Type val:(Map a) key:U60) : ∀(x:(List (Pair U60 a)))(List (Pair U60 a))
  (Map.to_list.go a (Map.empty a)     key) = λx x
  (Map.to_list.go a (Map.entry a val) key) = λx
    (List.cons (Pair U60 a) (Pair.new U60 a key val) x)
  (Map.to_list.go a (Map.nodes a lft rgt) key) = λx
    ((Map.to_list.go a lft (* key 2)) ((Map.to_list.go a rgt (+ (* key 2) 1)) x))

(Map.values -a:Type val:(Map a)) : (List a)
  (Map.values a val) = ((Map.values.go a val) (List.nil a))

(Map.values.go -a:Type val:(Map a)) : ∀(x:(List a))(List a)
  (Map.values.go a (Map.empty a)        ) = λx x
  (Map.values.go a (Map.entry a val    )) = λx (List.cons a val x)
  (Map.values.go a (Map.nodes a lft rgt)) = λx ((Map.values.go a lft) ((Map.values.go a rgt) x))

// Parser
// ======

Code : Type
  Code = String

(Answer a:Type): Type
  (Answer.parsed -a:Type code:(Code) result:a) : (Answer a)
  (Answer.failed -a:Type err:String) : (Answer a)

(Parser a:Type): Type
  (Parser a) = ∀(x: Code) (Answer a)

(Parser.is_name_char chr:Char) : Char
  (Parser.is_name_char chr) = 
  let is_letter = (| (& (<= 'a' chr) (<= chr 'z')) (& (<= 'A' chr) (<= chr 'Z')))
  let is_number = (& (<= '0' chr) (<= chr '9'))
  let is_symbol = (| (== '_' chr) (== '.' chr))
  (| is_letter (| is_number is_symbol))

(Char.is_upper chr:Char) : U60
(Char.is_upper chr) =
  (& (<= 'A' chr) (<= chr 'Z'))

(Char.is_lower chr:Char) : U60
(Char.is_lower chr) =
  (& (<= 'a' chr) (<= chr 'z'))

(Char.is_numeric chr:Char) : U60
(Char.is_numeric chr) =
  (& (<= '0' chr) (<= '9' chr))

(Parser.is_operator chr:Char) : U60
  (Parser.is_operator chr) =
    (| (== '+' chr)
    (| (== '-' chr)
    (| (== '*' chr)
    (| (== '/' chr)
    (| (== '%' chr)
    (| (== '&' chr)
    (| (== '|' chr)
    (| (== '^' chr)
    (| (== '<' chr)
    (| (== '>' chr)
    (| (== '=' chr)
    (| (== '!' chr)
       0))))))))))))

(Parser.bind -a:Type -b:Type a_parser:(Parser a) f:(∀(x:a)(Parser b))): (Parser b)
  (Parser.bind a b a_parser f) = λcode (Parser.bind.go a b f (a_parser code))

(Parser.bind.go -a:Type -b:Type f:(∀(x:a)(Parser b)) a_res:(Answer a)) : (Answer b)
  (Parser.bind.go a b f (Answer.parsed a code a_val)) = (f a_val code)
  (Parser.bind.go a b f (Answer.failed a err))        = (Answer.failed b err)

(Parser.done -a:Type value:a) : (Parser a)
  (Parser.done a value) = λcode (Answer.parsed a code value)

(Char.is_space chr:Char) : U60
  (Char.is_space chr) = (| (== 10 chr) (== 32 chr))

(Parser.parse_one) : (Parser U60)
  (Parser.parse_one) = λcode (Parser.parse_one.go code)

(Parser.parse_one.go code:String) : (Answer U60)
  (Parser.parse_one.go (String.cons x xs)) = (Answer.parsed U60 xs x)
  (Parser.parse_one.go String.nil)         = (Answer.parsed U60 String.nil 0)

(Parser.get_name) : ∀(code: Code)(Pair String String)
  (Parser.get_name) = λcode (Parser.get_name.go code)

(Parser.get_name.go code:Code) : (Pair String String)
  (Parser.get_name.go String.nil)              = (Pair.new String String String.nil String.nil)
  (Parser.get_name.go (String.cons head tail)) = (Parser.get_name.go_1 (Parser.is_name_char head) head tail)

(Parser.get_name.go_1 cond:U60 head:Char tail:String) : (Pair String String)
  (Parser.get_name.go_1 0 head tail) = (Pair.new String String (String.cons head tail) String.nil)
  (Parser.get_name.go_1 1 head tail) = (Parser.get_name.go_2 head (Parser.get_name.go tail))

(Parser.get_name.go_2 head:Char name_pair:(Pair String String)) : (Pair String String)
  (Parser.get_name.go_2 head (Pair.new Code String code name)) = (Pair.new Code String code (String.cons head name))

(Parser.matcher consume:Bool text:(List (∀(x:Char)U60))) : (Parser Bool)
  (Parser.matcher consume text) = λcode (Parser.matcher.go text code consume λx(x))

(Parser.matcher.go text:(List (∀(x:Char)U60)) code:Code consume:Bool redo:(∀(x:String)Code)) : (Answer Bool)
  (Parser.matcher.go (List.nil  (∀(x:Char)U60))      ys             consume redo) = (Answer.parsed Bool ((Bool.if ∀(x:String)String consume λx(x) redo) ys) Bool.true)
  (Parser.matcher.go (List.cons (∀(x:Char)U60) x xs) String.nil         consume redo) = (Answer.parsed Bool (redo String.nil) Bool.false)
  (Parser.matcher.go (List.cons (∀(x:Char)U60) x xs) (String.cons y ys) consume redo) = (Parser.matcher.go.test (x y) xs y ys consume redo)

(Parser.matcher.go.test cond:U60 xs:(List (∀(x:Char)U60)) y:Char ys:String consume:Bool redo:(∀(x:String)Code)) : (Answer Bool)
  (Parser.matcher.go.test 0 xs y ys consume redo) = (Answer.parsed Bool (redo (String.cons y ys)) Bool.false)
  (Parser.matcher.go.test 1 xs y ys consume redo) = (Parser.matcher.go xs ys consume λk(redo (String.cons y k)))

(Parser.text_comparer str:String) : (List ∀(c:Char)U60)
  (Parser.text_comparer String.nil)         = (List.nil  ∀(c:Char)U60)
  (Parser.text_comparer (String.cons x xs)) = (List.cons ∀(c:Char)U60 λc(== x c) (Parser.text_comparer xs))

(Parser.peek_conds conds:(List (∀(x:Char)U60))) : (Parser Bool)
  (Parser.peek_conds conds) = λcode ((Parser.matcher Bool.false conds) (Parser.skipper code))

(Parser.peek_text text:String) : (Parser Bool)
  (Parser.peek_text text) = λcode ((Parser.matcher Bool.false (Parser.text_comparer text)) (Parser.skipper code))

(Parser.match_conds conds:(List (∀(x:Char)U60))) : (Parser Bool)
  (Parser.match_conds conds) = λcode ((Parser.matcher Bool.true conds) (Parser.skipper code))

(Parser.match_text_here text:String) : (Parser Bool)
  (Parser.match_text_here text) = λcode ((Parser.matcher Bool.true (Parser.text_comparer text)) code)

(Parser.match_text text:String) : (Parser Bool)
  (Parser.match_text text) = λcode ((Parser.matcher Bool.true (Parser.text_comparer text)) (Parser.skipper code))

(Parser.parse_text_here text:String) : (Parser Unit)
  (Parser.parse_text_here text) = (Parser.bind Bool Unit (Parser.match_text_here text) λgot(Parser.text_here_got got))
  (Parser.parse_text_here text) = (Parser.bind Bool Unit (Parser.match_text_here text) λgot(Parser.text_here_got got))

(Parser.text_here_got got:Bool) : (Parser Unit)
  (Parser.text_here_got (Bool.false)) = λcode (Answer.failed Unit "Syntax Error.") 
  (Parser.text_here_got (Bool.true))  = (Parser.done Unit Unit.new)

(Parser.parse_text text:String) : (Parser Unit)
  (Parser.parse_text text) = λcode ((Parser.parse_text_here text) (Parser.skipper code))

// Skips spaces and comments
(Parser.skipper str:String) : String
  (Parser.skipper String.nil)         = String.nil
  (Parser.skipper (String.cons x xs)) = (Parser.skipper.go (Char.is_space x) (== x 47) x xs)

(Parser.skipper.go is_space:U60 is_slash:U60 x:Char xs:String): String
  (Parser.skipper.go 0 0 x xs) = (String.cons x xs)
  (Parser.skipper.go 1 c x xs) = (Parser.skipper xs)
  (Parser.skipper.go s 1 x xs) = (Parser.skipper.drop_comment xs)

(Parser.skipper.drop_comment str:String): String
  (Parser.skipper.drop_comment String.nil)         = String.nil
  (Parser.skipper.drop_comment (String.cons x xs)) = (Parser.skipper.drop_comment.go (== x 10) x xs) 

(Parser.skipper.drop_comment.go is_space:U60 x:Char xs:String): String
  (Parser.skipper.drop_comment.go 1 x xs) = (Parser.skipper xs)
  (Parser.skipper.drop_comment.go 0 x xs) = (Parser.skipper.drop_comment xs)

(Parser.parse_name_here) : (Parser String)
  (Parser.parse_name_here) = λcode (Parser.parse_name_here.go ((Parser.get_name) code))

(Parser.parse_name_here.go name:(Pair Code String)): (Answer String)
  (Parser.parse_name_here.go (Pair.new String String code name)) = (Answer.parsed String code name)

(Parser.parse_name) : (Parser String)
  (Parser.parse_name) = λcode ((Parser.parse_name_here) (Parser.skipper code))

(Parser.parse_end) : (Parser Bool)
  Parser.parse_end = λcode (Parser.parse_end.go code)
(Parser.parse_end.go code:String) : (Answer Bool)
  (Parser.parse_end.go String.nil)         = (Answer.parsed Bool String.nil Bool.true)
  (Parser.parse_end.go (String.cons x xs)) = (Answer.parsed Bool (String.cons x xs) Bool.false)

(Parser.parse_until -a:Type stop:(Parser Bool) parser:(Parser a)) : (Parser (List a))
  (Parser.parse_until a stop parser) = (Parser.bind Bool (List a) stop λs (Parser.parse_until.go a s stop parser))

(Parser.parse_until.go -a:Type s:Bool stop:(Parser Bool) parser:(Parser a)) : (Parser (List a))
  (Parser.parse_until.go a Bool.false stop parser) =
    (Parser.bind a        (List a) parser                             λhead 
    (Parser.bind (List a) (List a) (Parser.parse_until a stop parser) λtail 
    (Parser.done (List a) (List.cons a head tail))))
  (Parser.parse_until.go a Bool.true stop parser) =
    (Parser.done (List a) (List.nil a))

(Parser.grammar -a:Type choices:(List (Parser (Maybe a))))          : (Parser a)
  (Parser.grammar a (List.nil (Parser (Maybe a))))                 = λcode (Answer.failed a "TODO: Parser.grammer empty list")
  (Parser.grammar a (List.cons (Parser (Maybe a)) choice choices)) = λcode (Parser.grammar.go a (choice code) choices)

(Parser.grammar.go -a:Type choice_res:(Answer (Maybe a)) choices:(List (Parser (Maybe a)))) : (Answer a)
  (Parser.grammar.go a (Answer.failed a err)                        choices) = (Answer.failed a err)
  (Parser.grammar.go a (Answer.parsed a code (Maybe.none a))        choices) = ((Parser.grammar a choices) code)
  (Parser.grammar.go a (Answer.parsed a code (Maybe.some a result)) choices) = (Answer.parsed a code result)

// Note: unlike Rust's version, this won't rollback
(Parser.guard -a:Type head:(Parser Bool) body:(Parser a)) : (Parser (Maybe a))
  (Parser.guard a head body) = λcode (Parser.guard.go a (head code) body)

(Parser.guard.go -a:Type head_res:(Answer Bool) body:(Parser a)) : (Answer (Maybe a))
  (Parser.guard.go a (Answer.failed Bool err)             body) = (Answer.failed (Maybe a) err)
  (Parser.guard.go a (Answer.parsed Bool code Bool.false) body) = (Answer.parsed (Maybe a) code (Maybe.none a))
  (Parser.guard.go a (Answer.parsed Bool code Bool.true)  body) = ((Parser.bind a (Maybe a) body λgot (Parser.done _ (Maybe.some a got))) code)

// #############################################################################
// # Kind2                                                                     #
// #############################################################################


// Parsing
// -------

Op : Type 
 Op.ADD : Op
 Op.SUB : Op
 Op.MUL : Op
 Op.DIV : Op
 Op.MOD : Op
 Op.AND : Op
 Op.OR  : Op
 Op.XOR : Op
 Op.SHL : Op
 Op.SHR : Op
 Op.LTE : Op
 Op.LTN : Op
 Op.EQL : Op
 Op.GTE : Op
 Op.GTN : Op
 Op.NEQ : Op

Term : Type
  (Term.let name:Name expr:Term body:Term)           : Term
  (Term.cts name:Name list:(List Term))              : Term
  (Term.o32 op:Op val0:Term val1:Term)               : Term
  (Term.lam name:Name body:Term)                     : Term
  (Term.rfl expr:Term)                               : Term
  (Term.app f:Term x:Term)                           : Term
  (Term.var name:Name)                               : Term
  (Term.n32 value:U60)                               : Term
  (Term.u32)                                         : Term
  (Term.all name:Name type:Term body:Term)           : Term
  (Term.gol name:Name)                               : Term
  (Term.typ)                                         : Term
  (Term.ann expr:Term type:Term)                     : Term
  (Term.hol hash:U60)                                : Term     
  (Term.use name:Name numb:U60)                      : Term
  (Term.eql val0:Term val1:Term)                     : Term
  (Term.rwt name:Name witn:Term goal:Term expr:Term) : Term
  (Term.arg name:Name expr:Term)                     : Term

// TODO: complete
(Parser.parse_oper) : (Parser Op)
  (Parser.parse_oper) =
    (Parser.grammar Op (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "+")  (Parser.done Op Op.ADD))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "*")  (Parser.done Op Op.MUL))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text (String.cons '/' (String.nil)))  (Parser.done Op Op.DIV))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "%")  (Parser.done Op Op.MOD))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "&")  (Parser.done Op Op.AND))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "|")  (Parser.done Op Op.OR))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "^")  (Parser.done Op Op.XOR))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "<<") (Parser.done Op Op.SHL))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text ">>") (Parser.done Op Op.SHR))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "<=") (Parser.done Op Op.LTE))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "<")  (Parser.done Op Op.LTN))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "==") (Parser.done Op Op.EQL))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text ">=") (Parser.done Op Op.GTE))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text ">")  (Parser.done Op Op.GTN))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "!=") (Parser.done Op Op.NEQ))
                       (List.nil (Parser (Maybe Op)))))))))))))))))))

(Parser.parse_var) : (Parser (Maybe Term))
  (Parser.parse_var) = (Parser.bind String (Maybe Term) (Parser.parse_name) λname (Parser.parse_var.0 name))

(Parser.parse_var.0 name:String) : (Parser (Maybe Term))
  (Parser.parse_var.0 String.nil)   = (Parser.done _ (Maybe.none Term))
  (Parser.parse_var.0 (String.cons x xs)) = (Parser.parse_var.1
    (String.equal (String.cons x xs) "Type")
    (String.equal (String.cons x xs) "U60")
    (Char.is_upper x)
    (Char.is_numeric x)
    (String.cons x xs))

(Parser.parse_var.1 a:U60 b:U60 c:U60 d:U60 str:String) : (Parser (Maybe Term))
  (Parser.parse_var.1 1 b c d str) = (Parser.done (Maybe Term) (Maybe.some Term Term.typ))
  (Parser.parse_var.1 a 1 c d str) = (Parser.done (Maybe Term) (Maybe.some Term Term.u32))
  (Parser.parse_var.1 a b 1 d str) = (Parser.done (Maybe Term) (Maybe.some Term (Term.cts (Name.make str) (List.nil Term))))
  (Parser.parse_var.1 a b c 1 str) = (Parser.done (Maybe Term) (Maybe.some Term (Term.n32 (U60.read str))))
  (Parser.parse_var.1 a b c d str) =
    (Parser.bind Bool (Maybe Term) (Parser.match_text ":") (λis_ann (Parser.parse_var.2 (Bool.if U60 is_ann 1 0) str)))

(Parser.parse_var.2 i:U60 str:String) : (Parser (Maybe Term))
  (Parser.parse_var.2 0 str) = (Parser.done (Maybe Term) (Maybe.some Term (Term.var (Name.make str))))
  (Parser.parse_var.2 1 str) =
    (Parser.bind Term (Maybe Term) Parser.parse_term λterm (Parser.done (Maybe Term) (Maybe.some Term (Term.ann (Term.var (Name.make str)) term))))

(Parser.parse_let) : (Parser (Maybe Term))
(Parser.parse_let) = (Parser.guard Term (Parser.match_text "let")
  (Parser.bind String Term (Parser.parse_name)            λname
  (Parser.bind Bool Term (Parser.match_text ":")   λanns
  (Parser.parse_let_ann anns name))))

(Parser.parse_let_ann b:Bool name:String) : (Parser Term)
  (Parser.parse_let_ann Bool.true name) =
    (Parser.bind Term Term Parser.parse_term            λtype
    (Parser.bind Unit Term (Parser.parse_text "=") λskip
    (Parser.bind Term Term Parser.parse_term            λexpr
    (Parser.bind Term Term Parser.parse_term            λbody
    (Parser.done Term (Term.let (Name.make name) (Term.ann expr type) body))))))
  (Parser.parse_let_ann Bool.false name) =
    (Parser.bind Unit Term (Parser.parse_text "=") λskip
    (Parser.bind Term Term Parser.parse_term            λexpr
    (Parser.bind Term Term Parser.parse_term            λbody
    (Parser.done Term (Term.let (Name.make name) expr body)))))

(Parser.parse_def) : (Parser (Maybe Term))
(Parser.parse_def) = (Parser.guard Term (Parser.match_text "def")
  (Parser.bind String Term (Parser.parse_name)          λname
  (Parser.bind Bool Term (Parser.match_text ":") λanns
  (Parser.parse_def_ann anns name))))

(Parser.parse_def_ann b:Bool name:String) : (Parser Term)
  (Parser.parse_def_ann Bool.true name) =
    (Parser.bind Term Term Parser.parse_term            λtype
    (Parser.bind Unit Term (Parser.parse_text "=") λskip
    (Parser.bind Term Term Parser.parse_term            λexpr
    (Parser.bind Term Term Parser.parse_term            λbody
    (Parser.done Term (Term.def (Name.make name) (Term.ann expr type) body))))))
  (Parser.parse_def_ann Bool.false name) =
    (Parser.bind Unit Term (Parser.parse_text "=") λskip
    (Parser.bind Term Term Parser.parse_term            λexpr
    (Parser.bind Term Term Parser.parse_term            λbody
    (Parser.done Term (Term.def (Name.make name) expr body)))))

(Parser.parse_hol) : (Parser (Maybe Term))
(Parser.parse_hol) = (Parser.guard Term (Parser.match_text "_")
  (Parser.bind String Term (Parser.parse_name) λname
  (Parser.done Term (Term.hol (String.hash name)))))

(Parser.parse_gol) : (Parser (Maybe Term))
(Parser.parse_gol) = (Parser.guard Term (Parser.match_text "?")
  (Parser.bind String Term (Parser.parse_name) λname
  (Parser.done Term (Term.gol (Name.make name)))))

(Parser.parse_lam) : (Parser (Maybe Term))
(Parser.parse_lam) = (Parser.guard Term (Parser.match_text "λ")
  (Parser.bind String Term (Parser.parse_name) λname
  (Parser.bind Term Term (Parser.parse_term)   λbody
  (Parser.done Term (Term.lam (Name.make name) body)))))

(Parser.parse_all) : (Parser (Maybe Term))
(Parser.parse_all) = (Parser.guard Term (Parser.match_text "∀")
  (Parser.bind Unit Term (Parser.parse_text "(") λskip
  (Parser.bind String Term (Parser.parse_name)           λname
  (Parser.bind Unit Term (Parser.parse_text ":")  λskip
  (Parser.bind Term Term (Parser.parse_term)             λtype
  (Parser.bind Unit Term (Parser.parse_text ")") λskip
  (Parser.bind Term Term (Parser.parse_term)             λbody
  (Parser.done Term (Term.all (Name.make name) type body)))))))))

(Parser.parse_rwt) : (Parser (Maybe Term))
(Parser.parse_rwt) = (Parser.guard Term (Parser.match_text "rewrite")
  (Parser.bind String Term (Parser.parse_name)         λname
  (Parser.bind Unit Term (Parser.parse_text "with") λskip
  (Parser.bind Term Term (Parser.parse_term)           λwitn
  (Parser.bind Unit Term (Parser.parse_text "with") λskip
  (Parser.bind Term Term (Parser.parse_term)           λgoal
  (Parser.bind Term Term (Parser.parse_term)           λexpr
  (Parser.done Term (Term.rwt (Name.make name) witn goal expr)))))))))

(Parser.parse_rfl) : (Parser (Maybe Term))
(Parser.parse_rfl) = (Parser.guard Term (Parser.match_text "refl")
  (Parser.bind Term Term (Parser.parse_term) λexpr
  (Parser.done Term (Term.rfl expr))))

(Parser.parse_chr) : (Parser (Maybe Term))
(Parser.parse_chr) = (Parser.guard Term (Parser.match_text "'")
  (Parser.bind U60 Term (Parser.parse_one)             λchr
  (Parser.bind Unit Term (Parser.parse_text "with") λskip
  (Parser.done Term (Term.n32 chr)))))

(Parser.parse_o32) : (Parser (Maybe Term))
  (Parser.parse_o32) = (Parser.guard Term (Parser.peek_conds (List.cons ∀(x:Char)U60 λx(== x '(')
                                                             (List.cons ∀(x:Char)U60 λx(Parser.is_operator x)
                                                             (List.nil  ∀(x:Char)U60))))
    (Parser.bind Unit Term (Parser.parse_text "(") λskip
    (Parser.bind Op Term (Parser.parse_oper)               λoper
    (Parser.bind Term Term (Parser.parse_term)             λval0
    (Parser.bind Term Term (Parser.parse_term)             λval1
    (Parser.bind Unit Term (Parser.parse_text ")") λskip
    (Parser.done Term (Term.o32 oper val0 val1))))))))

(Parser.parse_cts) : (Parser (Maybe Term))
  (Parser.parse_cts) = (Parser.guard Term (Parser.peek_conds (List.cons ∀(x:Char)U60 λx(== x '(')
                                                             (List.cons ∀(x:Char)U60 λx(Char.is_upper x)
                                                             (List.nil  ∀(x:Char)U60))))
    (Parser.bind Unit Term (Parser.parse_text "(")                                                    λskip
    (Parser.bind String Term (Parser.parse_name)                                                              λname
    (Parser.bind (List Term) Term (Parser.parse_until Term (Parser.match_text ")") Parser.parse_term) λargs
    (Parser.done Term (Term.cts (Name.make name) args))))))

(Parser.parse_ann_eql) : (Parser (Maybe Term))
(Parser.parse_ann_eql) = (Parser.guard Term (Parser.match_text "(")
  (Parser.bind Term Term (Parser.parse_term)             λval0
  (Parser.bind Bool Term (Parser.match_text "::") λanns
  (Parser.parse_ann_eql_go anns val0))))

(Parser.parse_ann_eql_go b:Bool val0:Term) : (Parser Term)
  (Parser.parse_ann_eql_go Bool.true val0) =
    (Parser.bind Term Term (Parser.parse_term)             λval1
    (Parser.bind Unit Term (Parser.parse_text ")") λskip
    (Parser.done Term (Term.ann val0 val1))))
  (Parser.parse_ann_eql_go Bool.false val0) =
    (Parser.bind Unit Term (Parser.parse_text "==") λskip
    (Parser.bind Term Term (Parser.parse_term)             λval1
    (Parser.bind Unit Term (Parser.parse_text ")") λskip
    (Parser.done Term (Term.eql val0 val1)))))

(Parser.parse_app) : (Parser (Maybe Term))
(Parser.parse_app) = (Parser.guard Term (Parser.match_text "(")
  (Parser.bind Term Term (Parser.parse_term)                                                                λfunc
  (Parser.bind (List Term) Term (Parser.parse_until Term (Parser.match_text ")") Parser.parse_term) λargs
  (Parser.done Term ((List.fold Term ∀(a:Term)Term args λx(x) λxλtλf(t (Term.app f x))) func)))))

(Parser.parse_str) : (Parser (Maybe Term))
(Parser.parse_str) = (Parser.guard Term (Parser.match_text (String.cons '"' String.nil))
  (Parser.bind (List U60) Term (Parser.parse_until U60 (Parser.match_text (String.cons '"' String.nil)) Parser.parse_one) λchars
  (Parser.done Term (Parser.parse_str_make chars))))

(Parser.parse_str_make chars:(List U60)) : Term
  (Parser.parse_str_make (List.cons U60 x xs)) = (Term.cts (Name.make "String.cons") (List.cons Term  (Term.n32 x) (List.cons Term (Parser.parse_str_make xs) (List.nil Term))))
  (Parser.parse_str_make (List.nil U60))       = (Term.cts (Name.make "String.nil") (List.nil Term))

(Parser.parse_term) : (Parser Term)
(Parser.parse_term) =
  (Parser.bind Term          Term (Parser.parse_term.ini) λini
  (Parser.bind ∀(x:Term)Term Term (Parser.parse_term.end) λend
  (Parser.done Term (end ini))))

(Parser.parse_term.ini) : (Parser Term)
(Parser.parse_term.ini) =
  (Parser.grammar Term (List.cons (Parser (Maybe Term)) Parser.parse_def
                       (List.cons (Parser (Maybe Term)) Parser.parse_let
                       (List.cons (Parser (Maybe Term)) Parser.parse_cts
                       (List.cons (Parser (Maybe Term)) Parser.parse_o32
                       (List.cons (Parser (Maybe Term)) Parser.parse_all
                       (List.cons (Parser (Maybe Term)) Parser.parse_lam
                       (List.cons (Parser (Maybe Term)) Parser.parse_app
                       (List.cons (Parser (Maybe Term)) Parser.parse_chr
                       (List.cons (Parser (Maybe Term)) Parser.parse_str
                       (List.cons (Parser (Maybe Term)) Parser.parse_gol
                       (List.cons (Parser (Maybe Term)) Parser.parse_rfl
                       (List.cons (Parser (Maybe Term)) Parser.parse_rwt
                       (List.cons (Parser (Maybe Term)) Parser.parse_ann_eql
                       (List.cons (Parser (Maybe Term)) Parser.parse_hol
                       (List.cons (Parser (Maybe Term)) Parser.parse_var
                       (List.nil  (Parser (Maybe Term)))))))))))))))))))

(Parser.parse_term.end) : (Parser ∀(x:Term)Term)
(Parser.parse_term.end) =
  let xs = (List.cons (Parser (Maybe ∀(x:Term)Term)) (Parser.done (Maybe ∀(x:Term)Term) (Maybe.some ∀(x:Term)Term λx(x))) 
           (List.nil (Parser (Maybe ∀(x:Term)Term))))

  (Parser.grammar ∀(x:Term)Term xs)

Decl : Type
  (Decl.def_type lhs:Term rhs:Term) : Decl
  (Decl.def_rule lhs:Term rhs:Term) : Decl

KType : Type
  (KType.new lhs:Term rhs:Term) : KType

Rule : Type 
  (Rule.new lhs:Term rhs:Term list:Rule) : Rule
  (Rule.end) : Rule

Func : Type 
  (Func.new lhs:Term rhs:Term rule:Rule) : Func

File : Type 
  (File.new funcs:(Map Func)) : File

(Parser.parse_decl) : (Parser Decl)
(Parser.parse_decl) =
  (Parser.bind Term Decl (Parser.parse_term) λlhs
  (Parser.bind Bool Decl (Parser.match_text ":") λtyp
  (Parser.parse_decl_rhs typ lhs)))

(Parser.parse_decl_rhs typ:Bool lhs:Term) : (Parser Decl)
  (Parser.parse_decl_rhs Bool.true lhs) = (Parser.bind Term Decl (Parser.parse_term) λrhs (Parser.done Decl (Decl.def_type lhs rhs)))
  (Parser.parse_decl_rhs Bool.false lhs) = 
    (Parser.bind Unit Decl (Parser.parse_text "=") λskp
    (Parser.bind Term Decl (Parser.parse_term) λrhs
    (Parser.done Decl (Decl.def_rule lhs rhs))))

(Parser.parse_decls) : (Parser (List Decl))
  (Parser.parse_decls) = (Parser.parse_until Decl λcode((Parser.parse_end) (Parser.skipper code)) Parser.parse_decl)

(Term.read code:Code) : Term
  (Term.read code) = (Term.read.got ((Parser.parse_term) code))
(Term.read.got answer:(Answer Term)) : Term
  (Term.read.got (Answer.parsed Term code term)) = term
  (Term.read.got (Answer.failed Term err))       = (Term.var (Name.make (String.concat "[ParseError] " err)))

(File.read code:Code) : (Result File String)
  (File.read code) = (File.read.got ((Parser.parse_decls) code))
(File.read.got answer:(Answer (List Decl))) : (Result File String)
  (File.read.got (Answer.parsed (List Decl) code decls)) = (Result.ok File String (File.make decls))
  (File.read.got (Answer.failed (List Decl) err))        = (Result.err File String (String.concat "[ParseError] " err))

(Term.def Name Term Term) : Term
(Term.def nm val (Term.var name))                = (U60.if Term (Name.equal name nm) val (Term.var name))
(Term.def nm val (Term.hol hash))                = (Term.hol hash)
(Term.def nm val Term.typ)                       = Term.typ
(Term.def nm val Term.u32)                       = Term.u32
(Term.def nm val (Term.n32 numb))                = (Term.n32 numb)
(Term.def nm val (Term.o32 oper val0 val1))      = (Term.o32 oper (Term.def nm val val0) (Term.def nm val val1))
(Term.def nm val (Term.gol name))                = (Term.gol name)
(Term.def nm val (Term.ann xval xtyp))           = (Term.ann (Term.def nm val xval) (Term.def nm val xtyp))
(Term.def nm val (Term.let name expr body))      = (Term.let name (Term.def nm val expr) (Term.def.body nm val name body))
(Term.def nm val (Term.all name type body))      = (Term.all name (Term.def nm val type) (Term.def.body nm val name body))
(Term.def nm val (Term.lam name body))           = (Term.lam name (Term.def.body nm val name body))
(Term.def nm val (Term.app func argm))           = (Term.app (Term.def nm val func) (Term.def nm val argm))
(Term.def nm val (Term.cts ctid args))           = (Term.cts ctid (Term.def.many nm val args))
(Term.def nm val (Term.eql val0 val1))           = (Term.eql (Term.def nm val val0) (Term.def nm val val1))
(Term.def nm val (Term.rfl expr))                = (Term.rfl (Term.def nm val expr))
(Term.def nm val (Term.rwt name witn goal expr)) = (Term.rwt name (Term.def nm val witn) (Term.def.body nm val name goal) (Term.def nm val expr))

(Term.def.many nm:Name val:Term list:(List Term)) : (List Term)
  (Term.def.many nm val (List.nil Term))      = (List.nil Term)
  (Term.def.many nm val (List.cons Term x xs)) = (List.cons Term (Term.def nm val x) (Term.def.many nm val xs))

(Term.def.body nm:Name val:Term name:Name body:Term) : Term
  (Term.def.body nm val name body) = (Term.def.body.go (Name.equal nm name) nm val body)

(Term.def.body.go i:U60 nm:Name val:Term body:Term) : Term
  (Term.def.body.go 0 nm val body) = (Term.def nm val body)
  (Term.def.body.go 1 nm val body) = body
  
// Utils
// =====

(Ctr.get_id term:Term) : Name
  (Ctr.get_id (Term.cts ctid args)) = ctid
  (Ctr.get_id term)                 = (Name.make "?")

(Var.get_name term:Term) : Name
  (Var.get_name (Term.var name)) = name
  (Var.get_name x) = (Name.make "_")

(Arg.get term:Term cont:∀(x:Name)∀(y:Term)Term) : Term
  (Arg.get (Term.ann var expr) cont) = (cont (Var.get_name var) expr)
  (Arg.get term                cont) = (cont (Name.make "_") term)


// FIXME: this should be replaced by proper user of Maybe
(Func.empty) : Func
(Func.empty) = (Func.new (Term.var (Name.make "?")) (Term.var (Name.make "?")) Rule.end)

(Func.set_type func:Func new_lty:Term new_rty:Term) : Func
(Func.set_type (Func.new lty rty rules) new_lty new_rty) = (Func.new new_lty new_rty rules)

(Func.add_rule func:Func lhs:Term rhs:Term) : Func
(Func.add_rule (Func.new lty rty rules) lhs rhs) = (Func.new lty rty (Rule.new lhs rhs rules))

(Func.get_name func:Func file:File) : String
(Func.get_name (Func.new lty rty rules) file) = (Name.get_string (Ctr.get_id lty))

(Func.get func:Func cont:∀(lhs:Term)∀(rhs:Term)∀(rules:Rule)Func) : Func
  (Func.get (Func.new lty rty rules) cont) = (cont lty rty rules)

(Func.get_rules func:Func) : Rule
(Func.get_rules (Func.new lty rty rules)) = rules

(File.make decls:(List Decl)) : File
(File.make decls) = (File.new (File.make.go decls (Map.empty Func)))

(File.make.go list:(List Decl) file:(Map Func)) : (Map Func)
  (File.make.go (List.cons Decl (Decl.def_type lhs rhs) decls) file) =
    let ctid = (Ctr.get_id lhs)
    let func = (Func.new lhs rhs Rule.end)
    (File.make.go decls (Map.set Func file (Name.get_hash ctid) func))

  (File.make.go (List.cons Decl (Decl.def_rule lhs rhs) decls) file) =
    let ctid = (Ctr.get_id lhs)
    let func = (File.make.go.build lhs rhs)
    (File.make.go decls (Map.mut Func file (Name.get_hash ctid) func))

  (File.make.go.build lhs:Term rhs:Term) : ∀(x:Func)Func
    (File.make.go.build lhs rhs) = λx(Func.add_rule x (File.make.lhs lhs rhs) rhs)

  (File.make.go (List.nil Decl) file) = file

// Builds the left-hand side of a rule, annotating variable usage counts.
// TODO: use different constructor names
// FIXME: is this really needed? benchmark without
(File.make.lhs lhs:Term rhs:Term) : Term
  (File.make.lhs (Term.var name)      rhs) = (Term.use name (Uses name rhs))
  (File.make.lhs (Term.n32 numb)      rhs) = (Term.n32 numb)
  (File.make.lhs (Term.cts ctid args) rhs) = (Term.cts ctid (File.make.lhs.many args rhs))
  (File.make.lhs (Term.rfl expr)      rhs) = (Term.rfl (File.make.lhs expr rhs))
  (File.make.lhs term                 rhs) = term

(File.make.lhs.many lhs:(List Term) rhs:Term) : (List Term)
  (File.make.lhs.many  (List.nil Term)       rhs) = (List.nil Term)
  (File.make.lhs.many (List.cons Term x xs) rhs) = (List.cons Term (File.make.lhs x rhs) (File.make.lhs.many xs rhs))

(File.get_funcs file:File) : (Map Func)
  (File.get_funcs (File.new funs)) = funs

(File.got_func file:File ctid:Name) : (Pair File (Maybe Func))
  (File.got_func (File.new funs) ctid) =
    (Pair.get (Map Func) (Maybe Func) (Pair File (Maybe Func)) (Map.get Func funs (Name.get_hash ctid)) λfuns λgot
    (Pair.new File (Maybe Func) (File.new funs) got))

(File.is_ctr file:File ctid:Name) : U60
(File.is_ctr (File.new funs) ctid) =
  (Pair.get (Map Func) (Maybe Func) U60 (Map.get Func funs (Name.get_hash ctid)) λfuns λgot
  (Maybe.case Func U60 got 1 λfunc(File.is_ctr.func func)))

(File.is_ctr.func func:Func) : U60
  (File.is_ctr.func (Func.new lty rty Rule.end))                 = 1
  (File.is_ctr.func (Func.new lty rty (Rule.new lhs rhs rules))) = 0


// Stringifying
// ------------

(Term.show file:File term:Term) : String
  (Term.show file term) : ((Term.show.go term file) "")

(Term.show.go term:Term file:File) : ∀(x:String)String
  (Term.show.go (Term.var name) file) = λx((String.show.go (Name.get_string name)) x)
  (Term.show.go (Term.use name uses) file) = λx((String.show.go (Name.get_string name)) x)
  (Term.show.go (Term.hol hash) file) = λx((String.show.go "_") ((String.show.go (U60.show (hash))) x))
  (Term.show.go (Term.let name expr body) file) = 
    λx((String.show.go "let ")
      ((String.show.go (Name.get_string name))
      ((String.show.go " = ")
      ((Term.show.go expr file)
      ((String.show.go "; ")
      ((Term.show.go body file)
      x))))))
  (Term.show.go (Term.ann xval xtyp) file) =
    λx((String.show.go "(")
      ((Term.show.go xval file)
      ((String.show.go " :: ")
      ((Term.show.go xtyp file)
      ((String.show.go ")")
      x)))))
  (Term.show.go Term.typ file) =
    λx((String.show.go "Type")
      x)
  (Term.show.go Term.u32 file) =
    λx((String.show.go "U60")
      x)
  (Term.show.go (Term.n32 numb) file) =
    λx((String.show.go (U60.show numb))
      x)
  (Term.show.go (Term.o32 oper val0 val1) file) =
    λx((String.show.go "(")
      ((Oper.show.go oper)
      ((String.show.go " ")
      ((Term.show.go val0 file)
      ((String.show.go " ")
      ((Term.show.go val1 file)
      ((String.show.go ")")
      x)))))))
  (Term.show.go (Term.gol name) file) =
    λx((String.show.go "?")
      ((String.show.go (Name.get_string name))
      x))
  (Term.show.go (Term.all name type body) file) =
    λx((String.show.go "∀(")
      ((String.show.go (Name.get_string name))
      ((String.show.go ": ")
      ((Term.show.go type file)
      ((String.show.go ") ")
      ((Term.show.go body file)
      x))))))
  (Term.show.go (Term.lam name body) file) =
    λx((String.show.go "λ")
      ((String.show.go (Name.get_string name))
      ((String.show.go " ")
      ((Term.show.go body file)
      x))))
  (Term.show.go (Term.app func argm) file) =
    λx((String.show.go "(")
      ((Term.show.go func file)
      ((String.show.go " ")
      ((Term.show.go argm file)
      ((String.show.go ")")
      x)))))
  (Term.show.go (Term.cts ctid args) file) =
    λx((String.show.go "(")
      ((String.show.go (Name.get_string ctid))
      ((Term.show.go.cts.args args file)
      ((String.show.go ")")
      x))))
  (Term.show.go (Term.eql val0 val1) file) =
    λx((Term.show.go val0 file)
      ((String.show.go " == ")
      ((Term.show.go val1 file)
      x)))
  (Term.show.go (Term.rfl expr) file) =
    λx((String.show.go "refl ")
      ((Term.show.go expr file)
      x))
  (Term.show.go (Term.rwt name witn goal expr) file) =
    λx((String.show.go "rewrite ")
      ((String.show.go (Name.get_string name))
      ((String.show.go "with ")
      ((Term.show.go witn file)
      ((String.show.go "in ")
      ((Term.show.go goal file)
      ((String.show.go " ")
      ((Term.show.go expr file)
      x))))))))

  (Term.show.go.cts.args list:(List Term) file:File) : ∀(x:String)String
    (Term.show.go.cts.args (List.nil Term) file) = λx(x)
    (Term.show.go.cts.args (List.cons Term arg args) file) =
      λx((String.show.go " ")
        ((Term.show.go arg file)
        ((Term.show.go.cts.args args file)
        x)))


(String.show.go xs:String) : ∀(ys:String)String
(String.show.go xs) = λys(String.concat xs ys)

(Oper.show.go op:Op) : ∀(ys:String)String
  (Oper.show.go Op.ADD) = (String.show.go "+")
  (Oper.show.go Op.SUB) = (String.show.go "-")
  (Oper.show.go Op.MUL) = (String.show.go "*")
  (Oper.show.go Op.DIV) = (String.show.go (String.cons '/' String.nil)) // "/"
  (Oper.show.go Op.MOD) = (String.show.go "%")
  (Oper.show.go Op.AND) = (String.show.go "&")
  (Oper.show.go Op.OR)  = (String.show.go "|")
  (Oper.show.go Op.XOR) = (String.show.go "^")
  (Oper.show.go Op.SHL) = (String.show.go "<<")
  (Oper.show.go Op.SHR) = (String.show.go ">>")
  (Oper.show.go Op.LTN) = (String.show.go "<")
  (Oper.show.go Op.LTE) = (String.show.go "<=")
  (Oper.show.go Op.EQL) = (String.show.go "==")
  (Oper.show.go Op.GTE) = (String.show.go ">=")
  (Oper.show.go Op.GTN) = (String.show.go ">")
  (Oper.show.go Op.NEQ) = (String.show.go "!=")

(Newline) : String
(Newline) = (String.cons 10 String.nil)

(Context.show ctx:(List (Pair Name Term)) file:File) : String
  (Context.show (List.nil _) file) = ""
  (Context.show ctx file) =
    let new_ctx = (List.reverse (Pair Name Term) ctx)
    ((Context.show.build new_ctx file) "")

(Context.show.build ctx:(List (Pair Name Term)) file:File) : ∀(z:String)String
  (Context.show.build ctx file) = λz
    ((String.show.go "Context:")
    ((String.show.go Newline)
    ((Context.show.go ctx file)
      z)))

(Context.show.go ctx:(List (Pair Name Term)) file:File) : ∀(z:String)String
  (Context.show.go (List.nil _) file) = λz(z)
  (Context.show.go (List.cons (Pair Name Term) (Pair.new Name Term name type) rest) file) =
    λz((String.show.go "- ")
      ((String.show.go (Name.get_string name))
      ((String.show.go " : ") 
      ((Term.show.go type file)
      ((String.show.go Newline)
      ((Context.show.go rest file)
      z))))))

(File.show file:File) : String
  (File.show file) = ((File.show.go (Map.values Func (File.get_funcs file)) file) "")

(File.show.go list:(List Func) file:File) : ∀(z:String)String
  (File.show.go (List.nil Func) file) = λz(z)
  (File.show.go (List.cons Func (Func.new lhs.t lhs.r rules) funs) file) =
    λz((Term.show.go lhs.t file)
      ((String.show.go " : ")
      ((Term.show.go lhs.r file)
      ((String.show.go Newline)
      ((Rules.show.go rules file)
      ((String.show.go Newline)
      ((File.show.go funs file)
      z)))))))

(Rules.show.go rule:Rule file:File) : ∀(x:String)String
  (Rules.show.go Rule.end file) = λx(x)
  (Rules.show.go (Rule.new lhs rhs rules) file) =
    λx((Term.show.go lhs file)
      ((String.show.go " = ")
      ((Term.show.go rhs file)
      ((String.show.go Newline)
      ((Rules.show.go rules file)
      x)))))

// Evaluation
// ----------

// Counts free occurrences of a name
(Uses name:Name term:Term) : U60
  (Uses nm (Term.var name))                = (Name.equal name nm)
  (Uses nm (Term.use name numb))           = (Name.equal name nm)
  (Uses nm (Term.hol hash))                = 0
  (Uses nm Term.typ)                       = 0
  (Uses nm Term.u32)                       = 0
  (Uses nm (Term.n32 numb))                = 0
  (Uses nm (Term.o32 oper val0 val1))      = (+ (Uses nm val0) (Uses nm val1))
  (Uses nm (Term.gol name))                = 0
  (Uses nm (Term.ann xval xtyp))           = (Uses nm xval)
  (Uses nm (Term.let name expr body))      = (+ (Uses nm expr) (Uses.shadow (Name.equal nm name) nm body))
  (Uses nm (Term.all name type body))      = (+ (Uses nm type) (Uses.shadow (Name.equal nm name) nm body))
  (Uses nm (Term.lam name body))           = (Uses.shadow (Name.equal nm name) nm body)
  (Uses nm (Term.app func argm))           = (+ (Uses nm func) (Uses nm argm))
  (Uses nm (Term.cts ctid args))           = (Uses.many nm args)
  (Uses nm (Term.eql val0 val1))           = (+ (Uses nm val0) (Uses nm val1))
  (Uses nm (Term.rfl expr))                = (Uses nm expr)
  (Uses nm (Term.rwt name witn goal expr)) = (+ (Uses nm witn) (+ (Uses.shadow (Name.equal nm name) nm goal) (Uses nm expr)))

(Uses.many name:Name list:(List Term)) : U60
  (Uses.many nm (List.nil Term))                = 0
  (Uses.many nm (List.cons Term x xs))          = (+ (Uses nm x) (Uses.many nm xs))
  
(Uses.shadow cond:U60 name:Name body:Term) : U60
  (Uses.shadow 0 nm body)             = (Uses nm body)
  (Uses.shadow 1 nm body)             = 0

(Clone -a:Type n:U60 name:Name term:a ctx:(List (Pair Name a))) : (List (Pair Name a))
  (Clone a 0 name term ctx) = ctx
  (Clone a 1 name term ctx) = (List.cons (Pair Name a) (Pair.new Name a name term) ctx)
  (Clone a n name term ctx) = (List.cons (Pair Name a) (Pair.new Name a name term) (Clone a (- n 1) name term ctx))

(CloneFor -a:Type body:Term name:Name term:a ctx:(List (Pair Name a))) : (List (Pair Name a))
  (CloneFor a body name term ctx) = (Clone a (Uses name body) name term ctx)

HTerm : Type
  (HTerm.lev name:Name numb:U60)                         : HTerm
  (HTerm.let expr:HTerm body:HTerm)                      : HTerm
  (HTerm.cts ctid:U60 args:(List HTerm))                 : HTerm
  (HTerm.o32 op:Op val0:HTerm val1:HTerm)                : HTerm
  (HTerm.lam body:∀(x:HTerm)HTerm)                       : HTerm
  (HTerm.rfl expr:HTerm)                                 : HTerm
  (HTerm.app func:HTerm argm:HTerm)                      : HTerm
  (HTerm.var name:Name)                                  : HTerm
  (HTerm.n32 value:U60)                                  : HTerm
  (HTerm.u32)                                            : HTerm
  (HTerm.all type:HTerm body:HTerm)                      : HTerm
  (HTerm.gol name:Name)                                  : HTerm
  (HTerm.typ)                                            : HTerm
  (HTerm.ann expr:HTerm type:HTerm)                      : HTerm
  (HTerm.hol hash:Name)                                  : HTerm     
  (HTerm.use name:Name numb:U60)                         : HTerm
  (HTerm.eql val0:HTerm val1:HTerm)                      : HTerm
  (HTerm.rwt name:Name witn:HTerm goal:HTerm expr:HTerm) : HTerm

VarPair : Type
VarPair = (Pair Name HTerm)

//(High file:File term:Term vars:(List VarPair)) : HTerm
  //(High file term vars) = (Triple.get File (List VarPair) HTerm HTerm (High.go term file vars) λfile λvars λterm term)

(High.go term:Term file:File vars:(List VarPair)) : (Triple File (List VarPair) HTerm)
  (High.go (Term.var name) file vars) = (HighFind name file vars)

(HighFind name:Name file:File list:(List VarPair)) : (Triple File (List VarPair) HTerm) 
  (HighFind name file (List.nil VarPair)) = (Triple.new File (List VarPair) HTerm file (List.nil VarPair) (HTerm.var name))
  (HighFind name file (List.cons VarPair (Pair.new Name HTerm var val) vars)) = (HighFound (Name.equal name var) name var val file vars)

  (HighFound cond:U60 name:Name var:Name val:HTerm file:File vars:(List VarPair)) : (Triple File (List VarPair) HTerm)
    (HighFound 1 name var val file vars) = (Triple.new File (List VarPair) HTerm file vars val)
    (HighFound 0 name var val file vars) =
      (Triple.get File (List VarPair) HTerm (Triple File (List VarPair) HTerm) (HighFind name file vars) λfile λvars λgot
      (Triple.new File (List VarPair) HTerm file (List.cons VarPair (Pair.new Name HTerm var val) vars) got))

  (High.go (Term.use name count) file vars) =
    (High.go (Term.var name) file vars)

  (High.go (Term.ann xval xtyp) file vars) =
    (High.go xval file vars)

  (High.go Term.typ file vars) =
    (Triple.new File (List VarPair) HTerm file vars HTerm.typ)

  (High.go Term.u32 file vars) =
    (Triple.new File (List VarPair) HTerm file vars HTerm.u32)

  (High.go (Term.n32 numb) file vars) =
    (Triple.new File (List VarPair) HTerm file vars (HTerm.n32 numb))

  (High.go (Term.o32 oper val0 val1) file vars) =
    (Triple.get File (List VarPair) HTerm (Triple File (List VarPair) HTerm) (High.go val0 file vars) λfile λvars λval0
    (Triple.get File (List VarPair) HTerm (Triple File (List VarPair) HTerm) (High.go val1 file vars) λfile λvars λval1
    (Triple.new File (List VarPair) HTerm file vars (HTerm.o32 oper val0 val1))))

  (High.go (Term.gol name) file vars) =
    (Triple.new File (List VarPair) HTerm file vars (HTerm.gol name))

  //// TODO: can't infer lambda
  //// (High.go (Term.all name type body) file vars) =
    //// (Triple.get File (List VarPair) HTerm (Triple File (List VarPair) HTerm) (High.go type file vars) λfile λvars λtype
    //// (Triple.get File (List VarPair) HTerm (Triple File (List VarPair) HTerm) (High.go body file (CloneFor HTerm body name λhigh_x vars)) λfile λvars λbody
    //// (Triple.new File (List VarPair) HTerm file vars (HTerm.all type λhigh_x body))))

  //// FIXME: ?
  //// (High.go (Term.let name expr body) file vars) =
  ////   (Triple.get File (List VarPair) HTerm (Triple File (List VarPair) HTerm) (High.go expr file vars) λfile λvars λexpr
  ////   (Triple.get File (List VarPair) HTerm (Triple File (List VarPair) HTerm) (High.go body file (CloneFor HTerm body name expr vars)) λfile λvars λbody
  ////   (Triple.new File (List VarPair) HTerm file vars body)))

  (High.go (Term.app func argm) file vars) =
    (Triple.get File (List VarPair) HTerm (Triple File (List VarPair) HTerm) (High.go func file vars) λfile λvars λfunc
    (Triple.get File (List VarPair) HTerm (Triple File (List VarPair) HTerm) (High.go argm file vars) λfile λvars λargm
    (Triple.new File (List VarPair) HTerm file vars (HApply func argm))))
    
  //// TODO: waiting for High.go.many
  //// (High.go (Term.cts ctid args) file vars) =
    //// (Pair.get File (Maybe Func) (Pair File (Maybe Func)) (File.got_func file ctid)     λfile λfunc
    //// (Triple.get File (List VarPair) HTerm (Triple File (List VarPair) HTerm) (High.go.many args file vars) λfile λvars λargs
    //// (High.go.cts func (HTerm.cts ctid args) file vars)))


  (High.go (Term.arg name expr) file vars) = 
    (High.go expr file vars)

  (High.go (Term.eql val0 val1) file vars) =
    (Triple.get File (List VarPair) HTerm (Triple File (List VarPair) HTerm) (High.go val0 file vars) λfile λvars λval0
    (Triple.get File (List VarPair) HTerm (Triple File (List VarPair) HTerm) (High.go val1 file vars) λfile λvars λval1
    (Triple.new File (List VarPair) HTerm file vars (HTerm.eql val0 val1))))

  (High.go (Term.rfl expr) file vars) =
    (Triple.get File (List VarPair) HTerm (Triple File (List VarPair) HTerm) (High.go expr file vars) λfile λvars λexpr
    (Triple.new File (List VarPair) HTerm file vars (HTerm.rfl expr)))

  (High.go (Term.rwt name witn goal expr) file vars) =
    (Triple.get File (List VarPair) HTerm (Triple File (List VarPair) HTerm) (High.go expr file vars) λfile λvars λexpr
    (Triple.new File (List VarPair) HTerm file vars expr))


//(High.go.many xs:(List Term) file:File vars:(List VarPair)) : (Triple File (List VarPair) (List Term))
  //// (High.go.many (List.nil) file vars) =
  ////   (Triple.new File (List VarPair) (List Term) file vars (List.nil Term))
  //// (High.go.many (List.cons Term x xs) file vars) =
  ////   (Triple.get File (List VarPair) HTerm (High.go x file vars) λfile λvars λx
  ////   (Triple.get _ _ _ (Triple File (List VarPair) Term) (High.go.many xs file vars) λfile λvars λxs
  ////   (Triple.new File (List VarPair) Term file vars (List.cons Term x xs))))

   //(High.go (Term.hol hash) file vars) =
    //(Triple.new File (List VarPair) HTerm file vars (HTerm.hol hash))

//(High.go.cts func:(Maybe Func) term:HTerm file:File vars:(List VarPair)) : (Triple File (List VarPair) HTerm)
  //(High.go.cts (Maybe.none Func) term file vars)                          = (Triple.new File (List VarPair) HTerm file vars term)
  //(High.go.cts (Maybe.some Func (Func.new lty rty rules)) term file vars) = (HFindMatchingRule rules term file vars)

//// TODO: perhaps linearize term?
//(HFindMatchingRule rule:Rule term:HTerm file:File vars:(List VarPair)) : (Triple File (List VarPair) HTerm)
  //(HFindMatchingRule Rule.end term file vars) = (Triple.new File (List VarPair) HTerm file vars term)
  //(HFindMatchingRule (Rule.new lhs rhs rules) term file vars) = (HFindMatchingRule.found (HMatches.go lhs term) rhs rules file vars)

//(HFindMatchingRule.found triple_with_cond:(Triple Term HTerm U60) rhs:Term rules:Rule file:File vars:(List VarPair)) : (Triple File (List VarPair) HTerm)
  //(HFindMatchingRule.found (Triple.new Term HTerm U60 lhs term 0) rhs rules file vars) = (HFindMatchingRule rules term file vars)
  //(HFindMatchingRule.found (Triple.new Term HTerm U60 lhs term 1) rhs rules file vars) = (High.go rhs file ((HMatch.go lhs term) vars))

//// High-Order pattern-matching

//// Tests if a LHS matches with a HTerm.
//// Returns the reconstructed terms, and 0/1 if not/yes.
//(HMatches x:Term y:HTerm) : (Triple Term HTerm U60)
  //(HMatches x y) = (HMatches.go x y)
//(HMatches.go x:Term y:HTerm) : (Triple Term HTerm U60)
  //(HMatches.go (Term.use a_name uses) b) = (Triple.new Term HTerm U60 (Term.use a_name uses) b 1)
  //(HMatches.go a b) = (Triple.new Term HTerm U60 a b 0)
  //(HMatches.go (Term.n32 x_numb) (HTerm.n32 y_numb)) = (Triple.new Term HTerm U60 (Term.n32 x_numb) (HTerm.n32 y_numb) (== x_numb y_numb))

  //// (HMatches.go (Term.cts x.ctid x.args) (HTerm.cts y.ctid y.args)) = (HMatches.go.cts (Name.equal x.ctid y.ctid) x.ctid x.args y.ctid y.args)

  //(HMatches.go.cts cond:U60 x_ctid:U60 x_args:(List Term) y_ctid:U60 y_args:(List HTerm)) : (Triple Term HTerm U60)
  //// TODO: thats not supposed to work (?). Term.cts doesnt have a ctid, he has a name instead
  //// (HMatches.go.cts 0 x_ctid x_args y_ctid y_args) = (Triple.new _ _ _  (Term.cts x_ctid x_args) (HTerm.cts y_ctid y_args) 0)

    //// (HMatches.go.cts 1 x.ctid x.args y.ctid y.args) = (HMatches.go.cts.many x.args y.args 1 x.ctid y.ctid λz(z) λz(z))
    ////   (HMatches.go.cts.many Nil         Nil         m x.ctid y.ctid xs ys) = (Trip (Cts x.ctid (xs Nil)) (HCts y.ctid (ys Nil)) m)
    ////   (HMatches.go.cts.many (Cons a as) (Cons b bs) m x.ctid y.ctid xs ys) =
    ////     (HMatches.chain a b m λaλb(HMatches.go a b) λa λb λm
    ////     (HMatches.go.cts.many as bs m x.ctid y.ctid λk(xs (Cons a k)) λk(ys (Cons b k))))

  //// (HMatches.chain a b 0 fn cont) = (cont a b 0)
  //// (HMatches.chain a b 1 fn cont) = (Trip.Get (fn a b) cont)
  
//(HMatch x:Term y:HTerm) : (List VarPair)
  //(HMatch x y) = ((HMatch.go x y) (List.nil VarPair))

//// FIXME: finish type annotations
//(HMatch.go x:Term y:HTerm) : ∀(x:(List VarPair))(List VarPair)
  //// (HMatch.go (Term.cts x.ctid x.args) (HTerm.cts y.ctid y.args)) = (HMatch.go.many x.args y.args)

  //// (HMatch.go.many xs:(List Term) ys:(List Term)) : ∀(x:(List VarPair))(List VarPair)
  ////   (HMatch.go.many (List.cons Term x xs) (List.nil Term)) = λz (z)
  ////   (HMatch.go.many (List.cons Term x xs) (List.cons Term y ys)) = λz ((HMatch.go x y) ((HMatch.go.many xs ys) z))

  //// (HMatch.go (Term.use a_name uses) b) = λz (Clone uses a_name b z)

  //(HMatch.go a b) = λz z

(HApply func:HTerm args:HTerm) : HTerm
  (HApply (HTerm.lam fbody) argm) = (fbody argm)
  (HApply func         argm) = (HTerm.app func argm)


